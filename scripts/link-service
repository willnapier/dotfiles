#!/usr/bin/env nu
# Cross-platform Wiki Link Management Service
# Manages startup, status, and control of the unified wiki-link-manager
# Replaced Python comprehensive_link_manager with native Nushell (2025-10-27)

def main [action?: string = "status"] {
    let link_manager_script = $"($env.HOME)/.local/bin/wiki-link-manager"
    let log_dir = $"($env.HOME)/scripts/wiki-link-manager/logs"

    # Ensure log directory exists
    mkdir $log_dir

    let pid_file = $"($log_dir)/linkmanager.pid"
    let log_file = $"($log_dir)/linkmanager.out.log"
    let err_file = $"($log_dir)/linkmanager.err.log"

    # Multi-directory configuration
    let forge = $"($env.HOME)/Forge"
    let admin = $"($env.HOME)/Admin"
    let archives = $"($env.HOME)/Archives"
    let watch_dirs = ([$forge, $admin, $archives] | where {|p| $p | path exists})

    match $action {
        "start" => {
            if (link_service_running $pid_file) {
                print "âœ… Wiki link management service already running"
                return
            }

            print "ðŸš€ Starting universal wiki link management service..."
            print "   Script: wiki-link-manager (Nushell native)"
            print "   Features: Backlinks + Mark/Unmark unresolved"
            print "   Architecture: Multi-directory watchers (truly bidirectional)"
            print ""

            print $"ðŸ“‚ Watching ($watch_dirs | length) directories:"
            for dir in $watch_dirs {
                print $"   - ($dir | path basename)"
            }
            print ""

            # Spawn a watcher for each directory except the last
            # (we'll track the last one as the "main" PID)
            mut pids = []

            if ($watch_dirs | length) > 1 {
                let bg_dirs = ($watch_dirs | drop)
                for dir in $bg_dirs {
                    let dir_name = ($dir | path basename)
                    let dir_log = $"($log_dir)/($dir_name).out.log"
                    let dir_err = $"($log_dir)/($dir_name).err.log"

                    print $"ðŸš€ Spawning watcher for ($dir_name)..."

                    # Spawn background watcher
                    let bg_cmd = $"($link_manager_script) > '($dir_log)' 2> '($dir_err)' & echo $!"
                    let bg_pid = (bash -c $bg_cmd | str trim)
                    $pids = ($pids | append $bg_pid)
                }
            }

            # Start main watcher (last directory) in foreground-ish
            let main_dir = ($watch_dirs | last)
            let main_name = ($main_dir | path basename)
            print $"â­ Main watcher: ($main_name)"

            let main_cmd = $"($link_manager_script) > '($log_file)' 2> '($err_file)' & echo $!"
            let main_pid = (bash -c $main_cmd | str trim)
            $pids = ($pids | append $main_pid)

            # Save all PIDs (comma-separated) to track multi-instance
            ($pids | str join ",") | save --force $pid_file

            print ""
            print $"âœ… Wiki link management service started with ($pids | length) watchers"
            print $"ðŸ“ Main log: ($log_file)"
            print $"âŒ Errors: ($err_file)"
            if ($watch_dirs | length) > 1 {
                print $"ðŸ’¡ Additional logs in: ($log_dir)/<directory>.out.log"
            }
        }

        "stop" => {
            if not (link_service_running $pid_file) {
                print "âš ï¸  Link management service not running"
                return
            }

            let pids_str = (open $pid_file | str trim)
            let pids = ($pids_str | split row ",")

            print $"ðŸ›‘ Stopping link management service with ($pids | length) watchers..."

            for pid in $pids {
                try {
                    kill $pid
                    print $"   âœ… Stopped watcher PID ($pid)"
                } catch {
                    print $"   âš ï¸  PID ($pid) already stopped"
                }
            }

            rm -f $pid_file
            print "âœ… All link management watchers stopped"
        }

        "restart" => {
            main "stop"
            sleep 2sec
            main "start"
        }

        "status" => {
            if (link_service_running $pid_file) {
                let pids_str = (open $pid_file | str trim)
                let pids = ($pids_str | split row ",")

                print $"âœ… Wiki link management service running with ($pids | length) watchers"
                print "   Script: wiki-link-manager - unified Nushell system"
                print "   Architecture: Multi-directory (truly bidirectional)"

                # Show which PIDs are actually running
                print ""
                print "ðŸ“Š Watcher processes:"
                for pid in $pids {
                    let is_running = try {
                        ps | where pid == ($pid | into int) | length
                    } catch {
                        0
                    }

                    if $is_running > 0 {
                        print $"   âœ… PID ($pid) - running"
                    } else {
                        print $"   âŒ PID ($pid) - not found (crashed?)"
                    }
                }

                # Show recent log activity
                if ($log_file | path exists) {
                    print "\nðŸ“ Recent activity from main watcher:"
                    try {
                        open $log_file | lines | last 5 | each { |line| print $"   ($line)" }
                    } catch {
                        print "   (No recent activity)"
                    }
                }
            } else {
                print "âŒ Wiki link management service not running"
                print "ðŸ’¡ Run: link-service start"
            }
        }

        "logs" => {
            if ($log_file | path exists) {
                print "ðŸ“ Link management logs:"
                open $log_file | lines | last 20
            } else {
                print "âŒ No log file found"
            }
        }

        "errors" => {
            if ($err_file | path exists) {
                print "âŒ Link management errors:"
                open $err_file | lines | last 20
            } else {
                print "âœ… No error file found"
            }
        }

        _ => {
            print "Usage: link-service [start|stop|restart|status|logs|errors]"
            print ""
            print "Commands:"
            print "  start   - Start the link management service"
            print "  stop    - Stop the link management service"
            print "  restart - Restart the service"
            print "  status  - Show service status (default)"
            print "  logs    - Show recent service logs"
            print "  errors  - Show recent error logs"
        }
    }
}

def link_service_running [pid_file: path] {
    if not ($pid_file | path exists) {
        return false
    }

    let pid = (open $pid_file | str trim)

    # Check if process is actually running
    try {
        if ($nu.os-info.name == "macos") {
            let result = (^ps -p $pid | lines | length)
            $result > 1  # Header + process line
        } else {
            let result = (^ps -p $pid --no-headers | lines | length)
            $result > 0
        }
    } catch {
        false
    }
}