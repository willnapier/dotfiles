#!/usr/bin/env nu
# Cross-platform Wiki Link Management Service
# Manages two independent watchers: backlinks and resolve-mark
# Follows Unix "do one thing well" philosophy with composable tools
# Split architecture allows users to enable features independently

def main [action?: string = "status"] {
    let backlinks_script = $"($env.HOME)/.local/bin/wiki-backlinks"
    let resolve_script = $"($env.HOME)/.local/bin/wiki-resolve-mark"
    let log_dir = $"($env.HOME)/scripts/wiki-link-management/logs"

    # Ensure log directory exists
    mkdir $log_dir

    let pid_file = $"($log_dir)/link-service.pid"
    let backlinks_log = $"($log_dir)/backlinks.out.log"
    let backlinks_err = $"($log_dir)/backlinks.err.log"
    let resolve_log = $"($log_dir)/resolve.out.log"
    let resolve_err = $"($log_dir)/resolve.err.log"

    # Multi-directory configuration
    let forge = $"($env.HOME)/Forge"
    let admin = $"($env.HOME)/Admin"
    let archives = $"($env.HOME)/Archives"
    let assistants = $"($env.HOME)/Assistants"
    let watch_dirs = ([$forge, $admin, $archives, $assistants] | where {|p| $p | path exists})

    match $action {
        "start" => {
            if (link_service_running $pid_file) {
                print "âœ… Wiki link management service already running"
                return
            }

            print "ðŸš€ Starting wiki link management service..."
            print "   Architecture: Two independent watchers (Unix philosophy)"
            print "   - wiki-backlinks: Maintains ## Backlinks sections"
            print "   - wiki-resolve-mark: Marks/unmarks ?[[ for missing targets"
            print "   Multi-directory: Truly bidirectional updates"
            print ""

            print $"ðŸ“‚ Watching ($watch_dirs | length) directories:"
            for dir in $watch_dirs {
                print $"   - ($dir | path basename)"
            }
            print ""

            # Spawn ONE instance of each watcher (they internally watch ~/Forge)
            # Previous bug: spawned per-directory, but scripts hardcode ~/Forge â€” caused duplicates
            mut pids = []

            print "ðŸ”— Starting backlinks watcher..."
            let backlinks_cmd = $"nohup ($backlinks_script) > '($backlinks_log)' 2> '($backlinks_err)' & echo $!"
            let backlinks_pid = (bash -c $backlinks_cmd | str trim)
            $pids = ($pids | append $backlinks_pid)
            print $"   âœ… Backlinks watcher: PID ($backlinks_pid)"

            print "ðŸ”— Starting resolve-mark watcher..."
            let resolve_cmd = $"nohup ($resolve_script) > '($resolve_log)' 2> '($resolve_log)' & echo $!"
            let resolve_pid = (bash -c $resolve_cmd | str trim)
            $pids = ($pids | append $resolve_pid)
            print $"   âœ… Resolve-mark watcher: PID ($resolve_pid)"

            # Save PIDs
            ($pids | str join ",") | save --force $pid_file

            print ""
            print "âœ… Wiki link management service started (2 watchers)"
            print $"ðŸ“ Logs: ($log_dir)/"
        }

        "stop" => {
            if not (link_service_running $pid_file) {
                print "âš ï¸  Link management service not running"
                return
            }

            let pids_str = (open $pid_file | str trim)
            let pids = ($pids_str | split row ",")

            print $"ðŸ›‘ Stopping link management service with ($pids | length) watchers..."

            for pid in $pids {
                try {
                    kill $pid
                    print $"   âœ… Stopped watcher PID ($pid)"
                } catch {
                    print $"   âš ï¸  PID ($pid) already stopped"
                }
            }

            rm -f $pid_file
            print "âœ… All link management watchers stopped"
        }

        "restart" => {
            main "stop"
            sleep 2sec
            main "start"
        }

        "status" => {
            if (link_service_running $pid_file) {
                let pids_str = (open $pid_file | str trim)
                let pids = ($pids_str | split row ",")

                print $"âœ… Wiki link management service running"
                print $"   Total watchers: ($pids | length) = ($watch_dirs | length) dirs x 2 features"
                print "   Architecture: Independent backlinks + resolve-mark watchers"
                print "   Unix philosophy: Composable, separable features"

                # Show which PIDs are actually running
                print ""
                print "ðŸ“Š Watcher processes:"
                for pid in $pids {
                    let is_running = try {
                        ps | where pid == ($pid | into int) | length
                    } catch {
                        0
                    }

                    if $is_running > 0 {
                        print $"   âœ… PID ($pid) - running"
                    } else {
                        print $"   âŒ PID ($pid) - not found (crashed?)"
                    }
                }

                # Show recent log activity
                if ($backlinks_log | path exists) {
                    print "\nðŸ“ Recent backlinks activity:"
                    try {
                        open $backlinks_log | lines | last 3 | each { |line| print $"   ($line)" }
                    } catch {
                        print "   (No recent activity)"
                    }
                }

                if ($resolve_log | path exists) {
                    print "\nðŸ” Recent resolve-mark activity:"
                    try {
                        open $resolve_log | lines | last 3 | each { |line| print $"   ($line)" }
                    } catch {
                        print "   (No recent activity)"
                    }
                }
            } else {
                print "âŒ Wiki link management service not running"
                print "ðŸ’¡ Run: link-service start"
            }
        }

        "logs" => {
            print "ðŸ“ Link management logs:\n"

            if ($backlinks_log | path exists) {
                print "=== Backlinks watcher ==="
                open $backlinks_log | lines | last 15
                print ""
            }

            if ($resolve_log | path exists) {
                print "=== Resolve-mark watcher ==="
                open $resolve_log | lines | last 15
            }

            if not ($backlinks_log | path exists) and not ($resolve_log | path exists) {
                print "âŒ No log files found"
            }
        }

        "errors" => {
            print "âŒ Link management errors:\n"

            if ($backlinks_err | path exists) {
                print "=== Backlinks errors ==="
                open $backlinks_err | lines | last 15
                print ""
            }

            if ($resolve_err | path exists) {
                print "=== Resolve-mark errors ==="
                open $resolve_err | lines | last 15
            }

            if not ($backlinks_err | path exists) and not ($resolve_err | path exists) {
                print "âœ… No error files found"
            }
        }

        _ => {
            print "Usage: link-service [start|stop|restart|status|logs|errors]"
            print ""
            print "Commands:"
            print "  start   - Start both wiki-backlinks and wiki-resolve-mark watchers"
            print "  stop    - Stop all watchers"
            print "  restart - Restart the service"
            print "  status  - Show service status (default)"
            print "  logs    - Show recent service logs"
            print "  errors  - Show recent error logs"
            print ""
            print "Architecture:"
            print "  Two independent watchers per directory:"
            print "  - wiki-backlinks: Maintains ## Backlinks sections"
            print "  - wiki-resolve-mark: Marks ?[[ for missing targets"
            print "  Users can customize or disable features independently"
        }
    }
}

def link_service_running [pid_file: path] {
    if not ($pid_file | path exists) {
        return false
    }

    let pid = (open $pid_file | str trim)

    # Check if process is actually running
    try {
        if ($nu.os-info.name == "macos") {
            let result = (^ps -p $pid | lines | length)
            $result > 1  # Header + process line
        } else {
            let result = (^ps -p $pid --no-headers | lines | length)
            $result > 0
        }
    } catch {
        false
    }
}
