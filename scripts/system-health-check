#!/usr/bin/env nu

# system-health-check â€” Daily system health validator
# Catches dead timers/agents, failed services, uncommitted dotfiles, and missing Rust tool binaries.
# Cross-platform: systemd on Linux, launchd on macOS.
# Runs via systemd timer (Linux) or launchd plist (macOS) daily at 8am.

def is_macos [] { $nu.os-info.name == "macos" }

def log_msg [log_path: string, level: string, message: string] {
    let timestamp = (date now | format date "%Y-%m-%d %H:%M:%S")
    $"[($timestamp)] ($level) ($message)(char newline)" | save --append $log_path
}

# â”€â”€ Check 1a: Timer health (Linux) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Any enabled timer that's not active is dead and needs attention.
def check_timers [verbose: bool, fix: bool, log_path: string] {
    if $verbose { print "â”€â”€ Timers â”€â”€" }
    mut problems = []

    let result = (do { systemctl --user list-unit-files --type=timer --state=enabled --no-legend } | complete)
    if $result.exit_code != 0 {
        if $verbose { print "  Could not query timers" }
        return []
    }

    let timer_names = ($result.stdout | str trim | lines
        | where ($it | str trim | is-not-empty)
        | each {|l| $l | str trim | split row " " | get 0 })

    for timer in $timer_names {
        # Skip ourselves to avoid false positives on first run
        if $timer == "system-health-check.timer" { continue }

        let status = (do { systemctl --user is-active $timer } | complete | get stdout | str trim)

        if $status != "active" {
            let name = ($timer | str replace ".timer" "")
            if $fix {
                let r = (do { systemctl --user start $timer } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Started timer ($timer)"
                    if $verbose { print $"  ğŸ”§ ($name): was ($status), restarted" }
                } else {
                    $problems = ($problems | append $"Timer dead: ($name) [($status)]")
                    if $verbose { print $"  âŒ ($name): ($status) â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Timer dead: ($name) [($status)]")
                if $verbose { print $"  âŒ ($name): ($status)" }
            }
        } else if $verbose {
            let name = ($timer | str replace ".timer" "")
            print $"  âœ… ($name)"
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 1b: LaunchAgent health (macOS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Scans ~/Library/LaunchAgents/ for our plists, checks loaded state via launchctl.
def check_launchagents [verbose: bool, fix: bool, log_path: string] {
    if $verbose { print "â”€â”€ LaunchAgents â”€â”€" }
    mut problems = []

    let agents_dir = $"($env.HOME)/Library/LaunchAgents"
    if not ($agents_dir | path exists) {
        if $verbose { print "  No LaunchAgents directory"; print "" }
        return []
    }

    let wn_plists = (glob $"($agents_dir)/com.williamnapier.*.plist")
    let user_plists = (glob $"($agents_dir)/com.user.*.plist")
    let all_plists = ($wn_plists | append $user_plists)

    if ($all_plists | is-empty) {
        if $verbose { print "  No managed agents found"; print "" }
        return []
    }

    # Get all loaded services once (format: PID\tStatus\tLabel)
    let loaded_list = try {
        do { ^launchctl list } | complete | get stdout | lines
        | where ($it | str contains "com.williamnapier.") or ($it | str contains "com.user.")
        | each {|line|
            let parts = ($line | split row "\t")
            let pid = if ($parts | get 0) == "-" { null } else { try { $parts | get 0 | into int } catch { null } }
            let exit_code = try { $parts | get 1 | into int } catch { null }
            let label = ($parts | get 2 | str trim)
            { label: $label, pid: $pid, last_exit: $exit_code }
        }
    } catch { [] }

    for plist_path in $all_plists {
        let label = ($plist_path | path basename | str replace ".plist" "")
        # Skip ourselves
        if $label == "com.williamnapier.system-health-check" { continue }

        let info = ($loaded_list | where label == $label | first | default null)

        if $info == null {
            # Agent not loaded at all
            if $fix {
                let r = (do { ^launchctl load $plist_path } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Loaded agent ($label)"
                    if $verbose { print $"  ğŸ”§ ($label): was not loaded, loaded" }
                } else {
                    $problems = ($problems | append $"Agent not loaded: ($label)")
                    if $verbose { print $"  âŒ ($label): not loaded â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Agent not loaded: ($label)")
                if $verbose { print $"  âŒ ($label): not loaded" }
            }
        } else if $info.last_exit != null and $info.last_exit != 0 {
            # Loaded but last exit was non-zero
            if $fix {
                let _ = (do { ^launchctl unload $plist_path } | complete)
                let r = (do { ^launchctl load $plist_path } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Reloaded agent ($label)"
                    if $verbose { print $"  ğŸ”§ ($label): exit ($info.last_exit), reloaded" }
                } else {
                    $problems = ($problems | append $"Agent errored: ($label) [exit ($info.last_exit)]")
                    if $verbose { print $"  âŒ ($label): exit ($info.last_exit) â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Agent errored: ($label) [exit ($info.last_exit)]")
                if $verbose { print $"  âŒ ($label): exit ($info.last_exit)" }
            }
        } else if $verbose {
            let status = if $info.pid != null { $"running \(pid ($info.pid)\)" } else { "loaded, idle" }
            print $"  âœ… ($label): ($status)"
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 2a: Service health (Linux) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Failed services + key long-running services that should be active.
def check_services [verbose: bool, fix: bool, log_path: string] {
    if $verbose { print "â”€â”€ Services â”€â”€" }
    mut problems = []
    mut reported_names = []

    # Part A: any unit in failed state
    let failed = (do { systemctl --user --state=failed --no-legend --no-pager } | complete)
    if $failed.exit_code == 0 and ($failed.stdout | str trim | is-not-empty) {
        let lines = ($failed.stdout | str trim | lines | where ($it | str trim | is-not-empty))
        for line in $lines {
            let unit = ($line | str trim | split row " " | get 0)
            let name = ($unit | str replace ".service" "" | str replace ".timer" "")

            if $fix {
                let r = (do { systemctl --user restart $unit } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Restarted failed ($unit)"
                    if $verbose { print $"  ğŸ”§ ($name): was failed, restarted" }
                } else {
                    $problems = ($problems | append $"Service failed: ($name)")
                    $reported_names = ($reported_names | append $name)
                    if $verbose { print $"  âŒ ($name): failed â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Service failed: ($name)")
                $reported_names = ($reported_names | append $name)
                if $verbose { print $"  âŒ ($name): failed" }
            }
        }
    }

    # Part B: key long-running services that should always be active
    let key_services = ["link-service"]
    for svc in $key_services {
        if ($reported_names | any {|n| $n == $svc }) { continue }

        let unit = $"($svc).service"
        let enabled = (do { systemctl --user is-enabled $unit } | complete | get stdout | str trim)
        if $enabled != "enabled" { continue }

        let status = (do { systemctl --user is-active $unit } | complete | get stdout | str trim)
        if $status != "active" {
            if $fix {
                let r = (do { systemctl --user start $unit } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Started service ($svc)"
                    if $verbose { print $"  ğŸ”§ ($svc): was ($status), started" }
                } else {
                    $problems = ($problems | append $"Service dead: ($svc) [($status)]")
                    if $verbose { print $"  âŒ ($svc): ($status) â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Service dead: ($svc) [($status)]")
                if $verbose { print $"  âŒ ($svc): ($status)" }
            }
        } else if $verbose {
            print $"  âœ… ($svc)"
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 2b: Key macOS services â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Long-running agents that should have a PID (always-running daemons).
def check_mac_services [verbose: bool, fix: bool, log_path: string] {
    if $verbose { print "â”€â”€ Key Services â”€â”€" }
    mut problems = []

    let agents_dir = $"($env.HOME)/Library/LaunchAgents"

    # Services that should always be running (have a PID)
    let key_services = [
        "com.williamnapier.link-service"
        "com.williamnapier.syncthing-monitor"
    ]

    # Get loaded list
    let loaded_list = try {
        do { ^launchctl list } | complete | get stdout | lines
        | where ($it | str contains "com.williamnapier.") or ($it | str contains "com.user.")
        | each {|line|
            let parts = ($line | split row "\t")
            let pid = if ($parts | get 0) == "-" { null } else { try { $parts | get 0 | into int } catch { null } }
            let label = ($parts | get 2 | str trim)
            { label: $label, pid: $pid }
        }
    } catch { [] }

    for svc in $key_services {
        let plist_path = $"($agents_dir)/($svc).plist"
        if not ($plist_path | path exists) {
            if $verbose { print $"  âšª ($svc): no plist installed" }
            continue
        }

        let info = ($loaded_list | where label == $svc | first | default null)

        if $info == null or $info.pid == null {
            if $fix {
                if $info == null {
                    let _ = (do { ^launchctl load $plist_path } | complete)
                } else {
                    let _ = (do { ^launchctl unload $plist_path } | complete)
                    let _ = (do { ^launchctl load $plist_path } | complete)
                }
                log_msg $log_path "FIX" $"Reloaded service ($svc)"
                if $verbose { print $"  ğŸ”§ ($svc): reloaded" }
            } else {
                let status = if $info == null { "not loaded" } else { "loaded but no PID" }
                $problems = ($problems | append $"Service not running: ($svc)")
                if $verbose { print $"  âŒ ($svc): ($status)" }
            }
        } else if $verbose {
            print $"  âœ… ($svc): pid ($info.pid)"
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 3: Uncommitted dotfiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Staged or modified files in ~/dotfiles/ older than 24h.
def check_dotfiles [verbose: bool] {
    if $verbose { print "â”€â”€ Dotfiles â”€â”€" }

    let dotfiles_dir = $"($env.HOME)/dotfiles"
    if not ($dotfiles_dir | path exists) {
        if $verbose { print "  ~/dotfiles not found"; print "" }
        return []
    }

    let result = (do { git -C $dotfiles_dir status --porcelain } | complete)
    if $result.exit_code != 0 or ($result.stdout | str trim | is-empty) {
        if $verbose { print "  âœ… Clean"; print "" }
        return []
    }

    let changed_files = ($result.stdout | str trim | lines | each {|l|
        $l | str substring 3..
    })

    let now = (date now)
    let stale = ($changed_files | where {|f|
        let p = $"($dotfiles_dir)/($f)"
        if ($p | path exists) {
            ($now - (ls $p | get 0.modified)) > 24hr
        } else { false }
    })

    if ($stale | is-empty) {
        if $verbose {
            let n = ($changed_files | length)
            print $"  âœ… ($n) changed, all recent"
            print ""
        }
        return []
    }

    if $verbose {
        for f in $stale { print $"  âš  ($f)" }
        print ""
    }

    let count = ($stale | length)
    let label = if $count == 1 { "file" } else { "files" }
    [$"Dotfiles: ($count) uncommitted ($label) >24h old"]
}

# â”€â”€ Check 4: Rust tool deployment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Source in rust-projects/ but binary missing from ~/.local/bin/.
def check_rust_tools [verbose: bool] {
    if $verbose { print "â”€â”€ Rust Tools â”€â”€" }

    let rust_dir = $"($env.HOME)/dotfiles/rust-projects"
    let bin_dir = $"($env.HOME)/.local/bin"

    # Actively-used tools only â€” skip restore-*, *-to-continuum, etc.
    let tools = [
        [project binary];
        [ai-export-watcher ai-export-watcher]
        [concert-capture concert-capture]
        [continuum-activity continuum-activity]
        [forge-metadata-backup forge-metadata-backup]
        [readwise-sync readwise-sync]
        [wiki-resolve-batch wiki-resolve-batch]
        [yt-transcript yt-transcript]
    ]

    mut problems = []

    for tool in $tools {
        let src = $"($rust_dir)/($tool.project)"
        if not ($src | path exists) { continue }

        let bin = $"($bin_dir)/($tool.binary)"
        if ($bin | path exists) {
            if $verbose { print $"  âœ… ($tool.binary)" }
        } else {
            $problems = ($problems | append $"Rust tool missing: ($tool.binary)")
            if $verbose { print $"  âŒ ($tool.binary): source exists, no binary" }
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main [
    --verbose (-v)  # Show all checks even when healthy
    --fix (-f)      # Attempt auto-repair: restart dead timers/services
] {
    let log_path = $"($env.HOME)/.local/share/system-health-check.log"

    if $verbose {
        let platform = if (is_macos) { "macOS" } else { "Linux" }
        print $"System Health Check [($platform)]"
        print "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        print ""
    }

    # Platform-specific checks
    let timer_problems = if (is_macos) {
        check_launchagents $verbose $fix $log_path
    } else {
        check_timers $verbose $fix $log_path
    }

    let service_problems = if (is_macos) {
        check_mac_services $verbose $fix $log_path
    } else {
        check_services $verbose $fix $log_path
    }

    # Cross-platform checks
    let dotfile_problems = (check_dotfiles $verbose)
    let rust_problems = (check_rust_tools $verbose)

    let all_problems = ($timer_problems
        | append $service_problems
        | append $dotfile_problems
        | append $rust_problems)

    if ($all_problems | is-empty) {
        log_msg $log_path "INFO" "All checks passed"
        if $verbose { print "All checks passed." }
    } else {
        let count = ($all_problems | length)
        let label = if $count == 1 { "problem" } else { "problems" }

        log_msg $log_path "WARN" $"($count) ($label) found"
        for p in $all_problems {
            log_msg $log_path "WARN" $"  ($p)"
        }

        if not $verbose {
            print $"system-health-check: ($count) ($label):"
            for p in $all_problems {
                print $"  - ($p)"
            }
        } else {
            print $"($count) ($label) found."
        }

        # Desktop notification â€” platform-aware
        if (which notify-send | is-not-empty) {
            let body = ($all_problems | str join (char newline))
            do { notify-send --urgency=critical "System Health Check" $body } | ignore
        } else if (which osascript | is-not-empty) {
            let body = ($all_problems | str join ", ")
            do { osascript -e $"display notification \"($body)\" with title \"System Health Check\" sound name \"Basso\"" } | ignore
        }

        exit 1
    }
}
