#!/usr/bin/env nu

# system-health-check â€” Daily system health validator
# Catches dead timers/agents, failed services, uncommitted dotfiles, and missing Rust tool binaries.
# Cross-platform: systemd on Linux, launchd on macOS.
# Runs via systemd timer (Linux) or launchd plist (macOS) daily at 8am.

def is_macos [] { $nu.os-info.name == "macos" }

def log_msg [log_path: string, level: string, message: string] {
    let timestamp = (date now | format date "%Y-%m-%d %H:%M:%S")
    $"[($timestamp)] ($level) ($message)(char newline)" | save --append $log_path
}

# â”€â”€ Check 1a: Timer health (Linux) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Any enabled timer that's not active is dead and needs attention.
def check_timers [verbose: bool, fix: bool, log_path: string] {
    if $verbose { print "â”€â”€ Timers â”€â”€" }
    mut problems = []

    let result = (do { systemctl --user list-unit-files --type=timer --state=enabled --no-legend } | complete)
    if $result.exit_code != 0 {
        if $verbose { print "  Could not query timers" }
        return []
    }

    let timer_names = ($result.stdout | str trim | lines
        | where ($it | str trim | is-not-empty)
        | each {|l| $l | str trim | split row " " | get 0 })

    for timer in $timer_names {
        # Skip ourselves to avoid false positives on first run
        if $timer == "system-health-check.timer" { continue }

        let status = (do { systemctl --user is-active $timer } | complete | get stdout | str trim)

        if $status != "active" {
            let name = ($timer | str replace ".timer" "")
            if $fix {
                let r = (do { systemctl --user start $timer } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Started timer ($timer)"
                    if $verbose { print $"  ğŸ”§ ($name): was ($status), restarted" }
                } else {
                    $problems = ($problems | append $"Timer dead: ($name) [($status)]")
                    if $verbose { print $"  âŒ ($name): ($status) â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Timer dead: ($name) [($status)]")
                if $verbose { print $"  âŒ ($name): ($status)" }
            }
        } else if $verbose {
            let name = ($timer | str replace ".timer" "")
            print $"  âœ… ($name)"
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 1b: LaunchAgent health (macOS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Scans ~/Library/LaunchAgents/ for our plists, checks loaded state via launchctl.
def check_launchagents [verbose: bool, fix: bool, log_path: string] {
    if $verbose { print "â”€â”€ LaunchAgents â”€â”€" }
    mut problems = []

    let agents_dir = $"($env.HOME)/Library/LaunchAgents"
    if not ($agents_dir | path exists) {
        if $verbose { print "  No LaunchAgents directory"; print "" }
        return []
    }

    let wn_plists = (glob $"($agents_dir)/com.williamnapier.*.plist")
    let user_plists = (glob $"($agents_dir)/com.user.*.plist")
    let all_plists = ($wn_plists | append $user_plists)

    if ($all_plists | is-empty) {
        if $verbose { print "  No managed agents found"; print "" }
        return []
    }

    # Get all loaded services once (format: PID\tStatus\tLabel)
    let loaded_list = try {
        do { ^launchctl list } | complete | get stdout | lines
        | where ($it | str contains "com.williamnapier.") or ($it | str contains "com.user.")
        | each {|line|
            let parts = ($line | split row "\t")
            let pid = if ($parts | get 0) == "-" { null } else { try { $parts | get 0 | into int } catch { null } }
            let exit_code = try { $parts | get 1 | into int } catch { null }
            let label = ($parts | get 2 | str trim)
            { label: $label, pid: $pid, last_exit: $exit_code }
        }
    } catch { [] }

    for plist_path in $all_plists {
        let label = ($plist_path | path basename | str replace ".plist" "")
        # Skip ourselves
        if $label == "com.williamnapier.system-health-check" { continue }

        let info = ($loaded_list | where label == $label | first | default null)

        if $info == null {
            # Agent not loaded at all
            if $fix {
                let r = (do { ^launchctl load $plist_path } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Loaded agent ($label)"
                    if $verbose { print $"  ğŸ”§ ($label): was not loaded, loaded" }
                } else {
                    $problems = ($problems | append $"Agent not loaded: ($label)")
                    if $verbose { print $"  âŒ ($label): not loaded â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Agent not loaded: ($label)")
                if $verbose { print $"  âŒ ($label): not loaded" }
            }
        } else if $info.last_exit != null and $info.last_exit != 0 {
            # Loaded but last exit was non-zero
            if $fix {
                let _ = (do { ^launchctl unload $plist_path } | complete)
                let r = (do { ^launchctl load $plist_path } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Reloaded agent ($label)"
                    if $verbose { print $"  ğŸ”§ ($label): exit ($info.last_exit), reloaded" }
                } else {
                    $problems = ($problems | append $"Agent errored: ($label) [exit ($info.last_exit)]")
                    if $verbose { print $"  âŒ ($label): exit ($info.last_exit) â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Agent errored: ($label) [exit ($info.last_exit)]")
                if $verbose { print $"  âŒ ($label): exit ($info.last_exit)" }
            }
        } else if $verbose {
            let status = if $info.pid != null { $"running \(pid ($info.pid)\)" } else { "loaded, idle" }
            print $"  âœ… ($label): ($status)"
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 2a: Service health (Linux) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Failed services + key long-running services that should be active.
def check_services [verbose: bool, fix: bool, log_path: string] {
    if $verbose { print "â”€â”€ Services â”€â”€" }
    mut problems = []
    mut reported_names = []

    # Part A: any unit in failed state
    let failed = (do { systemctl --user --state=failed --no-legend --no-pager } | complete)
    if $failed.exit_code == 0 and ($failed.stdout | str trim | is-not-empty) {
        let lines = ($failed.stdout | str trim | lines | where ($it | str trim | is-not-empty))
        for line in $lines {
            let unit = ($line | str trim | split row " " | get 0)
            let name = ($unit | str replace ".service" "" | str replace ".timer" "")

            if $fix {
                let r = (do { systemctl --user restart $unit } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Restarted failed ($unit)"
                    if $verbose { print $"  ğŸ”§ ($name): was failed, restarted" }
                } else {
                    $problems = ($problems | append $"Service failed: ($name)")
                    $reported_names = ($reported_names | append $name)
                    if $verbose { print $"  âŒ ($name): failed â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Service failed: ($name)")
                $reported_names = ($reported_names | append $name)
                if $verbose { print $"  âŒ ($name): failed" }
            }
        }
    }

    # Part B: key long-running services that should always be active
    let key_services = ["link-service"]
    for svc in $key_services {
        if ($reported_names | any {|n| $n == $svc }) { continue }

        let unit = $"($svc).service"
        let enabled = (do { systemctl --user is-enabled $unit } | complete | get stdout | str trim)
        if $enabled != "enabled" { continue }

        let status = (do { systemctl --user is-active $unit } | complete | get stdout | str trim)
        if $status != "active" {
            if $fix {
                let r = (do { systemctl --user start $unit } | complete)
                if $r.exit_code == 0 {
                    log_msg $log_path "FIX" $"Started service ($svc)"
                    if $verbose { print $"  ğŸ”§ ($svc): was ($status), started" }
                } else {
                    $problems = ($problems | append $"Service dead: ($svc) [($status)]")
                    if $verbose { print $"  âŒ ($svc): ($status) â€” fix failed" }
                }
            } else {
                $problems = ($problems | append $"Service dead: ($svc) [($status)]")
                if $verbose { print $"  âŒ ($svc): ($status)" }
            }
        } else if $verbose {
            print $"  âœ… ($svc)"
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 2b: Key macOS services â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Long-running agents that should have a PID (always-running daemons).
def check_mac_services [verbose: bool, fix: bool, log_path: string] {
    if $verbose { print "â”€â”€ Key Services â”€â”€" }
    mut problems = []

    let agents_dir = $"($env.HOME)/Library/LaunchAgents"

    # Services that should always be running (have a PID).
    # Note: link-service spawns child watchers then exits â€” it's not expected to have a PID.
    let key_services = [
        "com.williamnapier.syncthing-monitor"
    ]

    # Get loaded list
    let loaded_list = try {
        do { ^launchctl list } | complete | get stdout | lines
        | where ($it | str contains "com.williamnapier.") or ($it | str contains "com.user.")
        | each {|line|
            let parts = ($line | split row "\t")
            let pid = if ($parts | get 0) == "-" { null } else { try { $parts | get 0 | into int } catch { null } }
            let label = ($parts | get 2 | str trim)
            { label: $label, pid: $pid }
        }
    } catch { [] }

    for svc in $key_services {
        let plist_path = $"($agents_dir)/($svc).plist"
        if not ($plist_path | path exists) {
            if $verbose { print $"  âšª ($svc): no plist installed" }
            continue
        }

        let info = ($loaded_list | where label == $svc | first | default null)

        if $info == null or $info.pid == null {
            if $fix {
                if $info == null {
                    let _ = (do { ^launchctl load $plist_path } | complete)
                } else {
                    let _ = (do { ^launchctl unload $plist_path } | complete)
                    let _ = (do { ^launchctl load $plist_path } | complete)
                }
                log_msg $log_path "FIX" $"Reloaded service ($svc)"
                if $verbose { print $"  ğŸ”§ ($svc): reloaded" }
            } else {
                let status = if $info == null { "not loaded" } else { "loaded but no PID" }
                $problems = ($problems | append $"Service not running: ($svc)")
                if $verbose { print $"  âŒ ($svc): ($status)" }
            }
        } else if $verbose {
            print $"  âœ… ($svc): pid ($info.pid)"
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 3: Uncommitted dotfiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Staged or modified files in ~/dotfiles/ older than 24h.
def check_dotfiles [verbose: bool] {
    if $verbose { print "â”€â”€ Dotfiles â”€â”€" }

    let dotfiles_dir = $"($env.HOME)/dotfiles"
    if not ($dotfiles_dir | path exists) {
        if $verbose { print "  ~/dotfiles not found"; print "" }
        return []
    }

    let result = (do { git -C $dotfiles_dir status --porcelain } | complete)
    if $result.exit_code != 0 or ($result.stdout | str trim | is-empty) {
        if $verbose { print "  âœ… Clean"; print "" }
        return []
    }

    let changed_files = ($result.stdout | str trim | lines | each {|l|
        $l | str substring 3..
    })

    let now = (date now)
    let stale = ($changed_files | where {|f|
        let p = $"($dotfiles_dir)/($f)"
        if ($p | path exists) {
            ($now - (ls $p | get 0.modified)) > 24hr
        } else { false }
    })

    if ($stale | is-empty) {
        if $verbose {
            let n = ($changed_files | length)
            print $"  âœ… ($n) changed, all recent"
            print ""
        }
        return []
    }

    if $verbose {
        for f in $stale { print $"  âš  ($f)" }
        print ""
    }

    let count = ($stale | length)
    let label = if $count == 1 { "file" } else { "files" }
    [$"Dotfiles: ($count) uncommitted ($label) >24h old"]
}

# â”€â”€ Check 4: Rust tool deployment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Source in rust-projects/ but binary missing from ~/.local/bin/.
def check_rust_tools [verbose: bool] {
    if $verbose { print "â”€â”€ Rust Tools â”€â”€" }

    let rust_dir = $"($env.HOME)/dotfiles/rust-projects"
    let bin_dir = $"($env.HOME)/.local/bin"

    # Actively-used tools only â€” skip restore-*, *-to-continuum, etc.
    let tools = [
        [project binary];
        [ai-export-watcher ai-export-watcher]
        [concert-capture concert-capture]
        [continuum-activity continuum-activity]
        [forge-metadata-backup forge-metadata-backup]
        [readwise-sync readwise-sync]
        [wiki-resolve-batch wiki-resolve-batch]
        [yt-transcript yt-transcript]
    ]

    mut problems = []

    for tool in $tools {
        let src = $"($rust_dir)/($tool.project)"
        if not ($src | path exists) { continue }

        let bin = $"($bin_dir)/($tool.binary)"
        if ($bin | path exists) {
            if $verbose { print $"  âœ… ($tool.binary)" }
        } else {
            $problems = ($problems | append $"Rust tool missing: ($tool.binary)")
            if $verbose { print $"  âŒ ($tool.binary): source exists, no binary" }
        }
    }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Check 5: DNA drift (Linux only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Detects drift from SYSTEM-DNA.md â€” user groups, system services,
# snapper health, cargo crates, npm globals, expected user units.
def check_dna_drift [verbose: bool] {
    if (is_macos) { return [] }

    if $verbose { print "â”€â”€ DNA Drift â”€â”€" }
    mut problems = []

    # 5a: User groups
    let expected_groups = ["wheel", "video", "input", "seat", "ollama"]
    let actual_groups = (do { id -nG } | complete | get stdout | str trim | split row " ")
    for g in $expected_groups {
        if not ($actual_groups | any {|a| $a == $g }) {
            $problems = ($problems | append $"DNA: user missing group '($g)'")
            if $verbose { print $"  âŒ group: ($g) missing" }
        }
    }
    if $verbose and ($problems | is-empty) { print "  âœ… groups" }

    # 5b: System services that should be enabled
    let expected_system_svcs = [
        "bluetooth" "keyd" "NetworkManager" "ollama"
        "seatd" "sshd" "systemd-resolved" "systemd-timesyncd" "tailscaled"
    ]
    mut svc_ok = true
    for svc in $expected_system_svcs {
        let unit = $"($svc).service"
        let status = (do { systemctl is-enabled $unit } | complete | get stdout | str trim)
        if $status != "enabled" {
            $problems = ($problems | append $"DNA: system service not enabled: ($svc)")
            if $verbose { print $"  âŒ system svc: ($svc) [($status)]" }
            $svc_ok = false
        }
    }
    if $verbose and $svc_ok { print "  âœ… system services" }

    # 5c: Snapper health
    let snapper_configs = (do { snapper list-configs } | complete)
    mut snapper_ok = true
    if $snapper_configs.exit_code != 0 {
        $problems = ($problems | append "DNA: snapper not accessible")
        if $verbose { print "  âŒ snapper: cannot list configs" }
        $snapper_ok = false
    } else {
        for cfg in ["root" "home"] {
            if not ($snapper_configs.stdout | str contains $cfg) {
                $problems = ($problems | append $"DNA: snapper config '($cfg)' missing")
                if $verbose { print $"  âŒ snapper: ($cfg) config missing" }
                $snapper_ok = false
            }
        }
        # Check snapper timers are enabled at system level
        for timer in ["snapper-timeline.timer" "snapper-cleanup.timer"] {
            let status = (do { systemctl is-enabled $timer } | complete | get stdout | str trim)
            if $status != "enabled" {
                $problems = ($problems | append $"DNA: ($timer) not enabled")
                if $verbose { print $"  âŒ snapper: ($timer) [($status)]" }
                $snapper_ok = false
            }
        }
    }
    if $verbose and $snapper_ok { print "  âœ… snapper" }

    # 5d: Cargo crates from crates.io (expected in PATH)
    let expected_crates = [
        "bat" "fd" "rg" "sd" "sk" "starship" "zoxide"
        "dotter" "dprint" "himalaya" "trash" "yazi" "zellij" "nu"
    ]
    mut crates_ok = true
    for bin in $expected_crates {
        if (which $bin | is-empty) {
            $problems = ($problems | append $"DNA: cargo crate not in PATH: ($bin)")
            if $verbose { print $"  âŒ crate: ($bin)" }
            $crates_ok = false
        }
    }
    if $verbose and $crates_ok { print "  âœ… cargo crates" }

    # 5e: npm globals
    let expected_npm = ["gemini" "codex"]
    mut npm_ok = true
    for bin in $expected_npm {
        if (which $bin | is-empty) {
            $problems = ($problems | append $"DNA: npm global not in PATH: ($bin)")
            if $verbose { print $"  âŒ npm: ($bin)" }
            $npm_ok = false
        }
    }
    if $verbose and $npm_ok { print "  âœ… npm globals" }

    # 5f: Expected user units that should be enabled
    let expected_user_units = [
        "ai-export-watcher.service"
        "collect-projects-watcher.service"
        "dropbox.service"
        "forge-link-manager.service"
        "git-auto-pull-watcher.service"
        "git-auto-push-watcher.service"
        "link-service.service"
        "syncthing.service"
        "web-clip-watcher.service"
        "claude-code-nightly-cleanup.timer"
        "collect-projects.timer"
        "continuum-auto-import.timer"
        "continuum-sync-claude.timer"
        "dotter-drift-monitor.timer"
        "frecency-daemon.timer"
        "helix-undo-cleanup.timer"
        "mail-sync.timer"
        "package-list-backup.timer"
        "readwise-sync.timer"
        "system-health-check.timer"
    ]
    mut units_ok = true
    for unit in $expected_user_units {
        let status = (do { systemctl --user is-enabled $unit } | complete | get stdout | str trim)
        if $status != "enabled" {
            let name = ($unit | str replace ".service" "" | str replace ".timer" "")
            $problems = ($problems | append $"DNA: user unit not enabled: ($name)")
            if $verbose { print $"  âŒ user unit: ($name) [($status)]" }
            $units_ok = false
        }
    }
    if $verbose and $units_ok { print "  âœ… user units" }

    if $verbose { print "" }
    $problems
}

# â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main [
    --verbose (-v)  # Show all checks even when healthy
    --fix (-f)      # Attempt auto-repair: restart dead timers/services
] {
    let log_path = $"($env.HOME)/.local/share/system-health-check.log"

    if $verbose {
        let platform = if (is_macos) { "macOS" } else { "Linux" }
        print $"System Health Check [($platform)]"
        print "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        print ""
    }

    # Platform-specific checks
    let timer_problems = if (is_macos) {
        check_launchagents $verbose $fix $log_path
    } else {
        check_timers $verbose $fix $log_path
    }

    let service_problems = if (is_macos) {
        check_mac_services $verbose $fix $log_path
    } else {
        check_services $verbose $fix $log_path
    }

    # Cross-platform checks
    let dotfile_problems = (check_dotfiles $verbose)
    let rust_problems = (check_rust_tools $verbose)
    let dna_problems = (check_dna_drift $verbose)

    let all_problems = ($timer_problems
        | append $service_problems
        | append $dotfile_problems
        | append $rust_problems
        | append $dna_problems)

    if ($all_problems | is-empty) {
        log_msg $log_path "INFO" "All checks passed"
        if $verbose { print "All checks passed." }
    } else {
        let count = ($all_problems | length)
        let label = if $count == 1 { "problem" } else { "problems" }

        log_msg $log_path "WARN" $"($count) ($label) found"
        for p in $all_problems {
            log_msg $log_path "WARN" $"  ($p)"
        }

        if not $verbose {
            print $"system-health-check: ($count) ($label):"
            for p in $all_problems {
                print $"  - ($p)"
            }
        } else {
            print $"($count) ($label) found."
        }

        # Desktop notification â€” platform-aware
        if (which notify-send | is-not-empty) {
            let body = ($all_problems | str join (char newline))
            do { notify-send --urgency=critical "System Health Check" $body } | ignore
        } else if (which osascript | is-not-empty) {
            let body = ($all_problems | str join ", ")
            do { osascript -e $"display notification \"($body)\" with title \"System Health Check\" sound name \"Basso\"" } | ignore
        }

        exit 1
    }
}
