#!/usr/bin/env nu
# Collect P. notation entries from journal to project files
# Three-tier automation: manual, cron, or auto-save trigger

def main [
    --verbose (-v)      # Show detailed output
    --dry-run (-d)      # Show what would be collected without writing
] {
    let forge_root = ([$env.HOME "Forge"] | path join)
    let journal_path = ([$forge_root "NapierianLogs" "DayPages"] | path join)
    let projects_path = ([$forge_root "Projects"] | path join)

    if not ($journal_path | path exists) {
        print $"Error: Journal path not found: ($journal_path)"
        return
    }

    # Ensure Projects directory exists
    mkdir $projects_path

    if $verbose {
        print "=== Project Collection Started ==="
        print $"Journal: ($journal_path)"
        print $"Projects: ($projects_path)\n"
    }

    # Find all P. entries in journal files
    let entries = (
        collect_project_entries $journal_path $verbose
    )

    if ($entries | is-empty) {
        if $verbose { print "No project entries found" }
        return
    }

    if $verbose {
        print $"Found ($entries | length) project entries\n"
    }

    # Group by project hierarchy
    let projects = (
        $entries
        | group-by {|entry|
            parse_project_hierarchy $entry.key | get filepath
        }
    )

    # Process each project
    $projects | transpose filepath entries | each {|project|
        let hierarchy = (parse_project_hierarchy ($project.entries | first | get key))

        if $dry_run {
            print $"Would update: ($hierarchy.filepath).md"
            print $"  Entries: ($project.entries | length)"
        } else {
            update_project_file $projects_path $hierarchy $project.entries $verbose
        }
    }

    if $verbose {
        print "\n=== Collection Complete ==="
    }
}

# Extract P. entries from journal files
def collect_project_entries [journal_path: string, verbose: bool] {
    let files = (glob ([$journal_path "**" "*.md"] | path join))

    if $verbose {
        print $"Scanning ($files | length) journal files..."
    }

    $files | each {|file|
        let content = (open $file)
        let date = extract_date_from_filename $file

        # Find all P. entries in this file
        $content
        | lines
        | enumerate
        | where {|row| $row.item =~ 'P\.[a-z0-9.-]+::'}
        | each {|row|
            let parsed = (parse_project_line $row.item)
            if ($parsed | is-not-empty) {
                # parse_project_line returns a list of matches (handles multiple per line)
                $parsed | each {|entry|
                    $entry | merge {
                        file: $file
                        date: $date
                        line_number: $row.index
                    }
                }
            }
        }
    }
    | flatten
    | flatten  # Extra flatten for multi-entry lines
    | compact
    | uniq-by key content  # Deduplicate identical entries from same journal file
}

# Parse a line with P. notation
# Uses unified syntax: period and comma are delimiters, space separates attributes
# Supports: P.project:: 2hr description-with-hyphens
#          P.project:: description 2hr (flexible ordering)
#          P.proj1:: 1hr work. P.proj2:: 30min other. (period-separated)
#          P.parent:: child1:: 1hr, child2:: 30min (comma-separated siblings)
def parse_project_line [line: string] {
    # Split on periods and commas to get individual entries
    # Pattern: captures P.project-name:: followed by content until delimiter (. or ,)
    let matches = ($line | parse --regex '(P\.[a-z0-9.-]+)::\s*([^.,]+)')

    if ($matches | is-empty) {
        return null
    }

    # Return all matches found (handles multiple projects per line)
    $matches | each {|match|
        {
            key: $match.capture0
            content: ($match.capture1 | str trim)
        }
    }
}

# Parse hierarchy from project key
def parse_project_hierarchy [key: string] {
    let parts = ($key | str replace 'P.' '' | split row '.')

    {
        root: ($parts | first)
        subproject: ($parts | skip 1 | str join '.')
        filepath: ($parts | str join '.')
        depth: ($parts | length)
    }
}

# Extract date from journal filename (assumes YYYY-MM-DD format)
def extract_date_from_filename [filepath: string] {
    let filename = ($filepath | path basename | str replace '.md' '')

    # Try to parse YYYY-MM-DD format
    let date_match = ($filename | parse --regex '(\d{4}-\d{2}-\d{2})')

    if ($date_match | is-not-empty) {
        $date_match | first | get capture0
    } else {
        # Fallback to file modification time
        ls $filepath | first | get modified | format date "%Y-%m-%d"
    }
}

# Update or create project file
def update_project_file [
    projects_path: string
    hierarchy: record
    entries: list
    verbose: bool
] {
    let filepath = $"($projects_path)/($hierarchy.filepath).md"
    let project_name = $hierarchy.root

    # Check if file exists
    let exists = ($filepath | path exists)

    if not $exists {
        # Create new project file
        if $verbose {
            print $"Creating: ($hierarchy.filepath).md"
        }

        let content = generate_project_template $hierarchy $entries
        $content | save $filepath
    } else {
        # Append new entries
        if $verbose {
            print $"Updating: ($hierarchy.filepath).md with ($entries | length) entries"
        }

        append_entries_to_project $filepath $entries
    }

    # Update parent with subproject link if needed
    if $hierarchy.depth > 1 {
        let parent_path = $"($projects_path)/($hierarchy.root).md"
        if ($parent_path | path exists) {
            add_subproject_to_parent $parent_path $hierarchy.filepath
        }
    }
}

# Generate new project file from template
def generate_project_template [hierarchy: record, entries: list] {
    let today = (date now | format date "%Y-%m-%d")
    let project_name = $hierarchy.filepath

    let header = if $hierarchy.depth == 1 {
        # Root project
        $"# ($project_name)

**Type**: {type}
**Status**: Active
**Created**: ($today)
**Updated**: ($today)

## Overview

{Project description}

## Subprojects

{Auto-generated}

## Journal Entries
"
    } else {
        # Subproject
        $"# ($project_name)

**Parent**: [[($hierarchy.root)]]
**Status**: Active
**Created**: ($today)

## Journal Entries
"
    }

    let entries_text = format_entries $entries

    $"($header)\n($entries_text)"
}

# Append entries to existing project file
def append_entries_to_project [filepath: string, entries: list] {
    let existing = (open $filepath)

    # Check for ## Journal Entries section
    if not ($existing =~ '## Journal Entries') {
        # Add section if missing
        let updated = $"($existing)\n\n## Journal Entries\n"
        $updated | save -f $filepath
    }

    # Filter out duplicates by checking if entry content already exists
    let new_entries = ($entries | where {|entry|
        # Create the entry line format that would appear in the file
        let entry_line = $"- ($entry.content)"
        # Check if this exact line already exists in the file
        not ($existing | str contains $entry_line)
    })

    # Only append if there are new entries
    if ($new_entries | is-empty) {
        return
    }

    # Format new entries
    let formatted_entries = format_entries $new_entries

    # Append to file
    let content = (open $filepath)
    $"($content)\n($formatted_entries)" | save -f $filepath
}

# Format entries for journal section
def format_entries [entries: list] {
    $entries
    | group-by date
    | transpose date entries
    | sort-by date --reverse
    | each {|day|
        let entry_lines = (
            $day.entries
            | each {|entry|
                $"- ($entry.content)"
            }
            | str join "\n"
        )

        $"### ($day.date)\n($entry_lines)"
    }
    | str join "\n\n"
}

# Add subproject link to parent file
def add_subproject_to_parent [parent_file: string, subproject_name: string] {
    let content = (open $parent_file)

    # Check if already listed
    let link = $"[[($subproject_name)]]"
    if ($content =~ $link) {
        return  # Already there
    }

    # Find ## Subprojects section
    if not ($content =~ '## Subprojects') {
        # Section doesn't exist, skip for now
        # (Could add it, but that's more complex)
        return
    }

    # Add link under Subprojects section
    let updated = (
        $content
        | str replace '## Subprojects' $"## Subprojects\n- [[($subproject_name)]]"
    )

    $updated | save -f $parent_file
}
