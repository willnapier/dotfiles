#!/usr/bin/env nu

# Activity Duration Processor
# Automatically calculates and inserts durations for any activity time range entries
# Processes entries like "s:: 0025-0755" -> "s:: 7hr 30min 0025-0755"
# Works with any activity code (single or multi-letter): w::, e::, m::, test::, etc.
# Supports shorthand: "p:: 0845-55" -> "p:: 10min 0845-0855"
# Created: 2025-09-07, Expanded: 2025-09-09

def main [file_path?: string] {
    let target_file = if ($file_path | is-empty) {
        # If no file specified, find recently modified .md files
        let files = (glob $"($env.HOME)/Obsidian.nosync/Forge/**/*.md")
        
        if ($files | length) == 0 {
            print "No markdown files found in vault"
            return
        }
        
        # Process files modified in the last 5 minutes
        let recent_files = ($files 
            | each { |file| 
                let stats = ($file | path expand | stat)
                {path: $file, modified: $stats.modified}
            }
            | where {|it| $it.modified > ((date now) - 5min)}
            | get path)
        
        if ($recent_files | length) == 0 {
            print "No recently modified markdown files found"
            return
        }
        
        # Process all recent files
        for file in $recent_files {
            print $"Processing: ($file)"
            # Recursively call self with each file
            ^activity-duration-processor $file
        }
        return  # Exit after processing all files
    } else {
        $file_path
    }
    
    if not ($target_file | path exists) {
        print $"File not found: ($target_file)"
        return
    }
    
    # Read file content and process line by line
    let content = (open $target_file)
    let lines = ($content | lines)
    
    let processed_lines = ($lines | each { |line|
        # Check if line matches pattern "[letters]:: ..." and extract time ranges
        let trimmed_line = ($line | str trim)
        let activity_pattern = ($trimmed_line | parse --regex '^([a-zA-Z]+):: (.+)$')
        
        if ($activity_pattern | length) > 0 {
            let activity_code = ($activity_pattern | first | get capture0)
            let content_raw = ($activity_pattern | first | get capture1)
            
            # Look for time range pattern HHMM-HHMM or HHMM-HH or HHMM-MM anywhere in the content
            let time_range_matches = ($content_raw | parse --regex '(\d{4})-(\d{2,4})')
            
            if ($time_range_matches | length) > 0 and (not ($content_raw | str contains "hr")) and (not ($content_raw | str contains "min")) {
                let match = ($time_range_matches | first)
                let start_time = ($match | get capture0)
                let end_time_raw = ($match | get capture1)
                let time_range_text = $"($start_time)-($end_time_raw)"
                
                # Handle both full HHMM and shorthand MM formats for end time
                let end_time = if ($end_time_raw | str length) == 2 {
                    # Shorthand: expand 2-digit end time to HHMM
                    let start_hour = ($start_time | str substring 0..<2 | into int)
                    let start_min = ($start_time | str substring 2..<4 | into int)
                    let end_min = ($end_time_raw | into int)
                    
                    if $end_min <= $start_min {
                        # Next hour
                        let end_hour_raw = $start_hour + 1
                        let end_hour = if $end_hour_raw >= 24 { $end_hour_raw - 24 } else { $end_hour_raw }
                        $"(if $end_hour < 10 { $"0($end_hour)" } else { $end_hour })(if $end_min < 10 { $"0($end_min)" } else { $end_min })"
                    } else {
                        # Same hour
                        $"(if $start_hour < 10 { $"0($start_hour)" } else { $start_hour })(if $end_min < 10 { $"0($end_min)" } else { $end_min })"
                    }
                } else if ($end_time_raw | str length) == 4 {
                    # Full format
                    $end_time_raw
                } else {
                    "" # Invalid
                }
                
                if ($end_time | str length) == 4 {
                    # Convert HHMM to HH:MM format for datetime parsing
                    let start_formatted = ($start_time | str substring 0..<2) + ":" + ($start_time | str substring 2..<4)
                    let end_formatted = ($end_time | str substring 0..<2) + ":" + ($end_time | str substring 2..<4)
                    
                    try {
                        # Use Nushell's native datetime parsing and calculation
                        let start_dt = ($start_formatted | into datetime)
                        let end_dt = ($end_formatted | into datetime)
                        
                        # Calculate duration (handle overnight)
                        let duration = if $end_dt < $start_dt {
                            ($end_dt + 1day) - $start_dt
                        } else {
                            $end_dt - $start_dt
                        }
                        
                        # Format as Nushell duration string
                        let duration_str = ($duration | to text)
                        
                        # Insert duration into the content, replacing the time range
                        let updated_content = ($content_raw | str replace $time_range_text $"($duration_str) ($start_time)-($end_time)")
                        
                        $"($activity_code):: ($updated_content)"
                    } catch {
                        $line  # Return original line if parsing fails
                    }
                } else {
                    $line  # Invalid end time format
                }
            } else {
                $line  # Already processed or not a time range
            }
        } else {
            $line  # Not an activity pattern
        }
    })
    
    let processed_content = ($processed_lines | str join "\n")
    
    # Only write if content changed
    if $processed_content != $content {
        $processed_content | save --force $target_file
    }
}