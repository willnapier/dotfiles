#!/usr/bin/env nu
# forge-link-watcher - Smart event-driven link manager
# Watches Forge, Admin, and Archives for link changes
# Only updates backlinks when links actually change (no global scans)
# Uses grep-on-demand instead of maintaining a full link index
#
# Usage: forge-link-watcher [--debounce-ms 2000]

def main [--debounce-ms: int = 2000] {
    # Verify required directories exist
    let forge = $"($env.HOME)/Forge"
    let admin = $"($env.HOME)/Admin"
    let archives = $"($env.HOME)/Archives"

    if not ($forge | path exists) {
        print "‚ùå Forge directory not found"
        return
    }

    print "üîó Starting smart link watcher..."
    print $"   Forge: ($forge)"
    print $"   Admin: ($admin) - optional"
    print $"   Archives: ($archives) - optional"
    print "   Mode: Grep-on-demand - no index overhead"
    print ""

    # Create watched paths list (immutable for closure capture)
    let watch_paths = if ($admin | path exists) and ($archives | path exists) {
        [$forge, $admin, $archives]
    } else if ($admin | path exists) {
        [$forge, $admin]
    } else if ($archives | path exists) {
        [$forge, $archives]
    } else {
        [$forge]
    }

    print $"üìÇ Watching ($watch_paths | length) directories for markdown files"
    print $"‚è±Ô∏è  Debounce: ($debounce_ms)ms"
    print ""

    # Watch all directories together (simplified approach)
    # This watches all three directories in a single watch command
    print $"üîç Monitoring all markdown files in watched directories..."

    # We need to watch each directory separately due to Nushell limitations
    # For now, just watch Forge as primary
    watch $forge --glob "**/*.md" --debounce-ms $debounce_ms {|operation, file_path, new_path|
        handle_change $operation $file_path $new_path [$forge, $admin, $archives]
    }
}

# Handle file change events
def handle_change [operation: string, file_path: string, new_path: string, watch_paths: list] {
    match $operation {
        "Write" => {
            # File was edited - check if links changed
            handle_write $file_path $watch_paths
        }
        "Rename" => {
            # File renamed - update all files that linked to old name
            handle_rename $file_path $new_path $watch_paths
        }
        "Create" => {
            # New file created - usually empty, skip backlink processing
            print $"‚ú® Created: ($file_path | path basename) - skipping backlinks for new file"
        }
        "Remove" => {
            # File deleted - optionally could mark links as broken
            print $"üóëÔ∏è  Deleted: ($file_path | path basename) - broken links will remain"
        }
        _ => {
            # Unknown operation
            print $"‚ùì Unknown operation: ($operation) on ($file_path)"
        }
    }
}

# Handle file write - check if links actually changed
def handle_write [file_path: string, watch_paths: list] {
    print $"üìù Modified: ($file_path | path basename)"

    # Extract current links from file (supports [[link]], ![[image]], ?[[unresolved]])
    let current_links = try {
        open $file_path | rg -o '[!?]?\[\[([^\]]+)\]\]' --replace '$1' | lines | uniq
    } catch {
        []
    }

    if ($current_links | is-empty) {
        print "   No wiki links in file, skipping"
        return
    }

    # TODO: Implement link change detection by comparing with cached state
    # For now, we'll update backlinks for all links in the file
    # This is still more efficient than scanning all 6,400 files

    print $"   Found ($current_links | length) links"

    # For each link, find the target file and update its backlinks
    for link in $current_links {
        let clean_link = ($link | str replace -r '[#|].*' '')

        # Find target file across all watched directories
        let target_file = find_target_file $clean_link $watch_paths

        if not ($target_file | is-empty) {
            update_backlinks $target_file $watch_paths
        }
    }
}

# Handle file rename - update all files that linked to old name
def handle_rename [old_path: string, new_path: string, watch_paths: list] {
    let old_name = ($old_path | path basename | str replace '.md' '')
    let new_name = ($new_path | path basename | str replace '.md' '')

    print $"üìõ Renamed: ($old_name) ‚Üí ($new_name)"

    # Filter to only existing paths
    let existing_paths = ($watch_paths | where {|p| $p | path exists})

    # Find all files that link to the old name (grep across all directories)
    mut affected_files = []
    for dir in $existing_paths {
        let files = try {
            ^rg -l $'\\[\\[($old_name)\\]\\]' $dir --glob "*.md" | lines
        } catch {
            []
        }
        $affected_files = ($affected_files | append $files)
    }

    if ($affected_files | is-empty) {
        print "   No files link to this note"
        return
    }

    print $"   Updating ($affected_files | length) files with new link name"

    # Update each affected file
    for file in $affected_files {
        try {
            let content = (open $file)
            let updated = ($content | str replace -a $"[[($old_name)]]" $"[[($new_name)]]")
            $updated | save -f $file
            print $"   ‚úÖ Updated: ($file | path basename)"
        } catch {
            print $"   ‚ùå Failed to update: ($file | path basename)"
        }
    }

    # Update backlinks in the renamed file itself
    update_backlinks $new_path $watch_paths
}

# Find target file for a wiki link across all watched directories
def find_target_file [link_name: string, watch_paths: list] {
    # Filter to only existing paths
    let existing_paths = ($watch_paths | where {|p| $p | path exists})

    # Try exact match first
    for dir in $existing_paths {
        let exact_match = try {
            ^fd -t f $"^($link_name).md$" $dir | lines | first
        } catch {
            ""
        }

        if not ($exact_match | is-empty) {
            return $exact_match
        }
    }

    # No match found
    return ""
}

# Update backlinks section in a file
def update_backlinks [file_path: string, watch_paths: list] {
    let file_name = ($file_path | path basename | str replace '.md' '')

    print $"   üîó Updating backlinks for: ($file_name)"

    # Filter to only existing paths
    let existing_paths = ($watch_paths | where {|p| $p | path exists})

    # Find all files that link to this file (grep across all directories)
    mut backlinks = []
    for dir in $existing_paths {
        let links = try {
            ^rg -l $'\\[\\[($file_name)\\]\\]' $dir --glob "*.md" | lines | where $it != $file_path
        } catch {
            []
        }
        $backlinks = ($backlinks | append $links)
    }

    if ($backlinks | is-empty) {
        print "      No backlinks found"
        # Still update the file to ensure it has a Backlinks section
        ensure_backlinks_section $file_path []
        return
    }

    print $"      Found ($backlinks | length) backlinks"

    # Convert file paths to wiki links
    let backlink_list = ($backlinks | each {|path|
        let name = ($path | path basename | str replace '.md' '')
        $"- [[($name)]]"
    })

    # Update the backlinks section
    ensure_backlinks_section $file_path $backlink_list
}

# Ensure file has a Backlinks section and update it
def ensure_backlinks_section [file_path: string, backlinks: list] {
    let content = try {
        open $file_path
    } catch {
        return
    }

    # Check if file has ## Backlinks section
    if ($content | str contains "## Backlinks") {
        # Replace existing backlinks section
        let before = ($content | str replace -r '## Backlinks\n.*' '' | str trim)
        let backlinks_section = if ($backlinks | is-empty) {
            "\n\n## Backlinks\n\n"
        } else {
            $"\n\n## Backlinks\n\n($backlinks | str join '\n')\n"
        }
        let updated = $"($before)($backlinks_section)"
        $updated | save -f $file_path
    } else {
        # Add backlinks section at end
        let backlinks_section = if ($backlinks | is-empty) {
            "\n\n## Backlinks\n\n"
        } else {
            $"\n\n## Backlinks\n\n($backlinks | str join '\n')\n"
        }
        $"($content)($backlinks_section)" | save -f $file_path
    }
}
