#!/usr/bin/env nu
# ‚ö†Ô∏è DEPRECATED - SUPERSEDED BY SPLIT ARCHITECTURE (2025-10-27)
#
# This unified script has been replaced by two independent watchers:
# - wiki-backlinks: Maintains ## Backlinks sections
# - wiki-resolve-mark: Marks/unmarks ?[[ for missing targets
#
# Reason for split: Unix "do one thing well" philosophy + customizability
# Users can now enable features independently for nushell-knowledge-tools repo
#
# Use: link-service start (manages both watchers)
# This file kept for reference only.
#
# === ORIGINAL HEADER (for reference) ===
# forge-link-manager - Unified Nushell link management system
# Combines backlink maintenance with mark/unmark unresolved links
# Replaces Python comprehensive_link_manager with native Nushell
#
# Features:
# - Marks [[unresolved]] links as ?[[unresolved]] when target doesn't exist
# - Cleans ?[[link]] back to [[link]] when file is created
# - Maintains automatic backlinks across all directories
# - Smart filtering to avoid false positives
# - Watches Forge, Admin, and Archives directories
# - Grep-on-demand architecture (no index overhead)
#
# Usage: forge-link-manager [--debounce-ms 2000]

# Smart filter configuration (ported from Python config.yaml)
def create_filter_config [] {
    {
        action_prefixes: ["tel:" "mailto:" "http:" "https:" "ftp:" "file:" "obsidian:"]
        system_paths: ["C:" "/usr/" "/var/" "/etc/" "~/" "\\\\"]
        auto_generated: ["unknown_filename_.*" "temp_.*" "IMG_.*" "Screenshot.*" "Pasted image .*" "image-.*"]
        reserved_names: ["^(con|prn|aux|nul|com[1-9]|lpt[1-9])$"]
        uuid_patterns: [
            "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$"
            "^[0-9a-f]{32}$"
            "^[0-9a-f]{40}$"
            "^[0-9a-f]{64}$"
        ]
        symlink_dirs: ["linked_media/" "attachments/" "assets/"]
        min_length: 2
        max_length: 100
        invalid_chars: ["\\" "/" ":" "*" "?" "\"" "<" ">" "|"]
    }
}

# Check if a link should be excluded from marking as unresolved
def should_exclude_link [link_name: string] {
    let config = (create_filter_config)

    # Too short or too long
    let len = ($link_name | str length)
    if $len < $config.min_length or $len > $config.max_length {
        return true
    }

    # Check action prefixes
    for prefix in $config.action_prefixes {
        if ($link_name | str starts-with $prefix) {
            return true
        }
    }

    # Check system paths
    for path in $config.system_paths {
        if ($link_name | str starts-with $path) {
            return true
        }
    }

    # Check auto-generated patterns (use regex matching)
    for pattern in $config.auto_generated {
        let matches = try {
            echo $link_name | rg $pattern | complete | get exit_code
        } catch {
            1
        }
        if $matches == 0 {
            return true
        }
    }

    # Check reserved names
    for pattern in $config.reserved_names {
        let matches = try {
            echo $link_name | rg $pattern | complete | get exit_code
        } catch {
            1
        }
        if $matches == 0 {
            return true
        }
    }

    # Check UUID patterns
    for pattern in $config.uuid_patterns {
        let matches = try {
            echo $link_name | rg $pattern | complete | get exit_code
        } catch {
            1
        }
        if $matches == 0 {
            return true
        }
    }

    # Check symlink directories
    for dir in $config.symlink_dirs {
        if ($link_name | str contains $dir) {
            return true
        }
    }

    # Check invalid filename characters
    for char in $config.invalid_chars {
        if ($link_name | str contains $char) {
            return true
        }
    }

    return false
}

def main [--debounce-ms: int = 2000] {
    # Verify required directories exist
    let forge = $"($env.HOME)/Forge"
    let admin = $"($env.HOME)/Admin"
    let archives = $"($env.HOME)/Archives"

    if not ($forge | path exists) {
        print "‚ùå Forge directory not found"
        return
    }

    print "üîó Starting unified link manager..."
    print $"   Forge: ($forge)"
    print $"   Admin: ($admin) - optional"
    print $"   Archives: ($archives) - optional"
    print "   Features: Mark/unmark + Backlinks + Smart filtering"
    print "   Mode: Grep-on-demand - no index overhead"
    print ""

    # Create watched paths list (immutable for closure capture)
    let watch_paths = if ($admin | path exists) and ($archives | path exists) {
        [$forge, $admin, $archives]
    } else if ($admin | path exists) {
        [$forge, $admin]
    } else if ($archives | path exists) {
        [$forge, $archives]
    } else {
        [$forge]
    }

    print $"üìÇ Watching ($watch_paths | length) directories for markdown files"
    print $"‚è±Ô∏è  Debounce: ($debounce_ms)ms"
    print ""

    # Watch Forge directory (primary)
    print $"üîç Monitoring Forge for file events..."
    watch $forge --glob "**/*.md" --debounce-ms $debounce_ms {|operation, file_path, new_path|
        handle_change $operation $file_path $new_path $watch_paths
    }
}

# Handle file change events
def handle_change [operation: string, file_path: string, new_path: string, watch_paths: list] {
    match $operation {
        "Write" => {
            # File was edited - mark new unresolved links + update backlinks
            handle_write $file_path $watch_paths
        }
        "Create" => {
            # File was created - clean resolved links + update backlinks
            handle_create $file_path $watch_paths
        }
        "Rename" => {
            # File renamed - update all references
            handle_rename $file_path $new_path $watch_paths
        }
        "Remove" => {
            # File deleted - mark references as unresolved
            handle_remove $file_path $watch_paths
        }
        _ => {
            print $"‚ùì Unknown operation: ($operation) on ($file_path)"
        }
    }
}

# Handle file creation - clean ?[[link]] markers for this file
def handle_create [file_path: string, watch_paths: list] {
    let file_name = ($file_path | path basename | str replace '.md' '')
    print $"‚ú® Created: ($file_name)"

    # Clean all ?[[filename]] references in other files
    clean_resolved_links $file_name $watch_paths

    # Update backlinks for any links in this new file
    # (usually empty, but if template has links, handle them)
    let links = try {
        open $file_path | rg -o '[!?]?\[\[([^\]]+)\]\]' --replace '$1' | lines | uniq
    } catch {
        []
    }

    if not ($links | is-empty) {
        print $"   Found ($links | length) links in new file"
        for link in $links {
            let clean_link = ($link | str replace -r '[#|].*' '')
            let target_file = find_target_file $clean_link $watch_paths
            if not ($target_file | is-empty) {
                update_backlinks $target_file $watch_paths
            }
        }
    }
}

# Handle file write - mark new unresolved links + update backlinks
def handle_write [file_path: string, watch_paths: list] {
    print $"üìù Modified: ($file_path | path basename)"

    # Extract current links from file
    let current_links = try {
        open $file_path | rg -o '[!?]?\[\[([^\]]+)\]\]' --replace '$1' | lines | uniq
    } catch {
        []
    }

    if ($current_links | is-empty) {
        print "   No wiki links in file, skipping"
        return
    }

    print $"   Found ($current_links | length) links"

    # Mark any new unresolved links in this file
    mark_unresolved_in_file $file_path $current_links $watch_paths

    # For each link, update backlinks in target file
    for link in $current_links {
        let clean_link = ($link | str replace -r '[#|].*' '')

        # Find target file across all watched directories
        let target_file = find_target_file $clean_link $watch_paths

        if not ($target_file | is-empty) {
            update_backlinks $target_file $watch_paths
        }
    }
}

# Handle file rename - update all files that linked to old name
def handle_rename [old_path: string, new_path: string, watch_paths: list] {
    let old_name = ($old_path | path basename | str replace '.md' '')
    let new_name = ($new_path | path basename | str replace '.md' '')

    print $"üìõ Renamed: ($old_name) ‚Üí ($new_name)"

    # Filter to only existing paths
    let existing_paths = ($watch_paths | where {|p| $p | path exists})

    # Find all files that link to the old name (grep across all directories)
    mut affected_files = []
    for dir in $existing_paths {
        let files = try {
            ^rg -l $'\\[\\[($old_name)\\]\\]' $dir --glob "*.md" | lines
        } catch {
            []
        }
        $affected_files = ($affected_files | append $files)
    }

    if ($affected_files | is-empty) {
        print "   No files link to this note"
        return
    }

    print $"   Updating ($affected_files | length) files with new link name"

    # Update each affected file - handle both [[link]] and ?[[link]]
    for file in $affected_files {
        try {
            let content = (open $file)
            # Update both regular and unresolved links
            let updated = ($content
                | str replace -a $"[[($old_name)]]" $"[[($new_name)]]"
                | str replace -a $"?[[($old_name)]]" $"?[[($new_name)]]"
            )
            $updated | save -f $file
            print $"   ‚úÖ Updated: ($file | path basename)"
        } catch {
            print $"   ‚ùå Failed to update: ($file | path basename)"
        }
    }

    # Update backlinks in the renamed file itself
    update_backlinks $new_path $watch_paths
}

# Handle file removal - mark all references as unresolved
def handle_remove [file_path: string, watch_paths: list] {
    let file_name = ($file_path | path basename | str replace '.md' '')
    print $"üóëÔ∏è  Deleted: ($file_name)"

    # Find all files that reference this deleted file
    let existing_paths = ($watch_paths | where {|p| $p | path exists})

    mut affected_files = []
    for dir in $existing_paths {
        let files = try {
            ^rg -l $'\\[\\[($file_name)\\]\\]' $dir --glob "*.md" | lines
        } catch {
            []
        }
        $affected_files = ($affected_files | append $files)
    }

    if ($affected_files | is-empty) {
        print "   No files link to this note"
        return
    }

    print $"   Marking ($affected_files | length) references as unresolved"

    # Mark all references as unresolved
    for file in $affected_files {
        try {
            let content = (open $file)
            # Add ? marker to all unmarked references
            let updated = ($content | str replace -a $"[[($file_name)]]" $"?[[($file_name)]]")
            $updated | save -f $file
            print $"   ‚ö†Ô∏è Marked unresolved: ($file | path basename)"
        } catch {
            print $"   ‚ùå Failed to update: ($file | path basename)"
        }
    }
}

# Mark unresolved links within a specific file
def mark_unresolved_in_file [file_path: string, links: list, watch_paths: list] {
    mut content = try {
        open $file_path
    } catch {
        return
    }

    mut marked_count = 0

    for link in $links {
        let clean_link = ($link | str replace -r '[#|].*' '')

        # Skip if already marked with ?
        if ($link | str starts-with "?") {
            continue
        }

        # Skip if excluded by smart filter
        if (should_exclude_link $clean_link) {
            continue
        }

        # Check if target file exists
        let target_file = find_target_file $clean_link $watch_paths

        if ($target_file | is-empty) {
            # File doesn't exist - mark as unresolved
            # Handle various link formats: [[link]], [[link|alias]], [[link#header]]
            $content = ($content | str replace -a $"[[($link)]]" $"?[[($link)]]")
            $marked_count = $marked_count + 1
        }
    }

    if $marked_count > 0 {
        $content | save -f $file_path
        print $"   ‚ö†Ô∏è Marked ($marked_count) new unresolved links"
    }
}

# Clean ?[[link]] markers when file is created
def clean_resolved_links [file_name: string, watch_paths: list] {
    let existing_paths = ($watch_paths | where {|p| $p | path exists})

    # Find all files that have ?[[filename]] references
    mut affected_files = []
    for dir in $existing_paths {
        let files = try {
            ^rg -l $'\\?\\[\\[($file_name)\\]\\]' $dir --glob "*.md" | lines
        } catch {
            []
        }
        $affected_files = ($affected_files | append $files)
    }

    if ($affected_files | is-empty) {
        return
    }

    print $"   üßπ Cleaning ?[[ markers in ($affected_files | length) files"

    for file in $affected_files {
        try {
            let content = (open $file)
            # Remove ? marker from all formats: ?[[link]], ?[[link|alias]], ?[[link#header]]
            # Use sd for complex replacements to avoid Nushell regex escaping issues
            let updated = ($content | sd $"\\?\\[\\[($file_name)\\]\\]" $"[[($file_name)]]")
            $updated | save -f $file
            print $"   ‚úÖ Cleaned: ($file | path basename)"
        } catch {
            print $"   ‚ùå Failed to clean: ($file | path basename)"
        }
    }
}

# Find target file for a wiki link across all watched directories
def find_target_file [link_name: string, watch_paths: list] {
    # Filter to only existing paths
    let existing_paths = ($watch_paths | where {|p| $p | path exists})

    # Try exact match first
    for dir in $existing_paths {
        let exact_match = try {
            ^fd -t f $"^($link_name).md$" $dir | lines | first
        } catch {
            ""
        }

        if not ($exact_match | is-empty) {
            return $exact_match
        }
    }

    # No match found
    return ""
}

# Update backlinks section in a file
def update_backlinks [file_path: string, watch_paths: list] {
    let file_name = ($file_path | path basename | str replace '.md' '')

    print $"   üîó Updating backlinks for: ($file_name)"

    # Filter to only existing paths
    let existing_paths = ($watch_paths | where {|p| $p | path exists})

    # Find all files that link to this file (grep across all directories)
    # Include both [[link]] and ?[[link]] in backlinks
    mut backlinks = []
    for dir in $existing_paths {
        let links = try {
            ^rg -l $'\\[\\[($file_name)\\]\\]' $dir --glob "*.md" | lines | where $it != $file_path
        } catch {
            []
        }
        $backlinks = ($backlinks | append $links)
    }

    if ($backlinks | is-empty) {
        print "      No backlinks found"
        # Still update the file to ensure it has a Backlinks section
        ensure_backlinks_section $file_path []
        return
    }

    print $"      Found ($backlinks | length) backlinks"

    # Convert file paths to wiki links
    let backlink_list = ($backlinks | each {|path|
        let name = ($path | path basename | str replace '.md' '')
        $"- [[($name)]]"
    })

    # Update the backlinks section
    ensure_backlinks_section $file_path $backlink_list
}

# Ensure file has a Backlinks section and update it
def ensure_backlinks_section [file_path: string, backlinks: list] {
    let content = try {
        open $file_path
    } catch {
        return
    }

    # Check if file has ## Backlinks section
    if ($content | str contains "## Backlinks") {
        # Replace existing backlinks section
        let before = ($content | str replace -r '## Backlinks\n.*' '' | str trim)
        let backlinks_section = if ($backlinks | is-empty) {
            "\n\n## Backlinks\n\n"
        } else {
            $"\n\n## Backlinks\n\n($backlinks | str join '\n')\n"
        }
        let updated = $"($before)($backlinks_section)"
        $updated | save -f $file_path
    } else {
        # Add backlinks section at end
        let backlinks_section = if ($backlinks | is-empty) {
            "\n\n## Backlinks\n\n"
        } else {
            $"\n\n## Backlinks\n\n($backlinks | str join '\n')\n"
        }
        $"($content)($backlinks_section)" | save -f $file_path
    }
}
