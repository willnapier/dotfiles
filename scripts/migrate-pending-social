#!/usr/bin/env nu
# Migrate pending social files from old system to new NapierianLogs structure
# Uses AI to classify files and handle accordingly

def main [
    --verbose (-v)      # Show detailed output
    --dry-run (-d)      # Show what would be done without doing it
] {
    let pending_path = ([$env.HOME "Forge" "Social" "pendingPlacement"] | path join)
    let napier_logs = ([$env.HOME "Forge" "NapierianLogs"] | path join)
    let archive_base = ([$env.HOME "Forge" "Social"] | path join)

    if not ($pending_path | path exists) {
        print $"Error: pendingPlacement directory not found: ($pending_path)"
        return
    }

    # Check for OpenAI API key
    if ($env.OPENAI_API_KEY? | is-empty) {
        print "Error: OPENAI_API_KEY environment variable is required"
        return
    }

    if $verbose {
        print "=== Migrating Pending Social Files ==="
        print $"Source: ($pending_path)"
        print $"Target: ($napier_logs)"
    }

    # Find all markdown files
    let files = (glob ([$pending_path "*.md"] | path join))

    if ($files | is-empty) {
        print "No files to migrate"
        return
    }

    if $verbose {
        print $"Found ($files | length) files to classify\n"
    }

    # Classify each file
    let classifications = ($files | each { |file|
        if $verbose {
            print $"Classifying: (basename $file)"
        }

        let classification = (classify_social_file $file)

        if $verbose {
            print $"  → ($classification.category) - confidence: ($classification.confidence)"
            print $"     ($classification.reasoning)\n"
        }

        {name: $file, classification: $classification}
    })

    # Summary
    print "\n=== Classification Summary ==="
    let by_category = ($classifications | group-by {|f| $f.classification.category })

    $by_category | transpose category files | each { |row|
        print $"($row.category): ($row.files | length) files"
    }

    # Process each category
    if not $dry_run {
        print "\n=== Processing Files ==="

        # Create archive directories if needed
        mkdir ([$archive_base "contacts-archive"] | path join)
        mkdir ([$archive_base "historical-archive"] | path join)

        # Process substantive files
        let substantive = ($classifications | where {|f| $f.classification.category == "substantive" })
        if not ($substantive | is-empty) {
            print $"\nMigrating ($substantive | length) substantive files to NapierianLogs..."
            $substantive | each { |file|
                let success = (migrate_substantive_file $file.name $napier_logs $verbose)
                if $success {
                    rm $file.name
                }
            }
        }

        # Archive contact-only files
        let contacts = ($classifications | where {|f| $f.classification.category == "contact-only" })
        if not ($contacts | is-empty) {
            print $"\nArchiving ($contacts | length) contact-only files..."
            $contacts | each { |file|
                let target = ([$archive_base "contacts-archive" (basename $file.name)] | path join)
                mv $file.name $target
                if $verbose {
                    print $"  Archived: (basename $file.name)"
                }
            }
        }

        # Archive outdated files
        let outdated = ($classifications | where {|f| $f.classification.category == "outdated" })
        if not ($outdated | is-empty) {
            print $"\nArchiving ($outdated | length) outdated files..."
            $outdated | each { |file|
                let target = ([$archive_base "historical-archive" (basename $file.name)] | path join)
                mv $file.name $target
                if $verbose {
                    print $"  Archived: (basename $file.name)"
                }
            }
        }

        print "\n=== Migration Complete ==="
    } else {
        print "\n(Dry run - no files modified)"
    }
}

# Classify a social file using AI
def classify_social_file [file_path: string] {
    let content = open $file_path | str trim

    # Prepare classification prompt
    let prompt = [
        "Analyze this old social/contact note and classify it into ONE category:"
        ""
        "Categories:"
        "- substantive: Contains meaningful interaction details, conversation notes, insights, or context worth preserving for ongoing relationships"
        "- contact-only: Just contact information (phone, email, address, business card) without substantial interaction content"
        "- outdated: Event notes or information from 2015-2018 with no ongoing relevance (past parties, old addresses, completed events)"
        ""
        "File content:"
        "```"
        $content
        "```"
        ""
        "Return ONLY a JSON object:"
        "{\"category\": \"substantive|contact-only|outdated\", \"confidence\": 0.95, \"reasoning\": \"brief explanation\"}"
        ""
        "Guidelines:"
        "- If it has conversation details, insights, or relationship context → substantive"
        "- If it's just a phone number, address, or business card → contact-only"
        "- If it's about a specific past event with no ongoing value → outdated"
    ] | str join (char nl)

    # Call OpenAI API
    let body = {
        model: "gpt-4o-mini",
        messages: [
            {role: "system", content: "You are classifying old social notes for migration. Be practical about what has ongoing value."},
            {role: "user", content: $prompt}
        ],
        temperature: 0.3,
        max_tokens: 150
    } | to json

    let response = http post https://api.openai.com/v1/chat/completions $body --headers {
        "Authorization": $"Bearer ($env.OPENAI_API_KEY)",
        "Content-Type": "application/json"
    }

    # Parse response
    try {
        $response | get choices.0.message.content | from json
    } catch {
        print $"Warning: Failed to parse AI response for ($file_path)"
        {category: "outdated", confidence: 0.0, reasoning: "AI parse failed - defaulting to outdated"}
    }
}

# Migrate a substantive file to NapierianLogs with modern format
def migrate_substantive_file [file_path: string, napier_logs: string, verbose: bool] {
    let content = open $file_path
    let basename = (basename $file_path | str replace ".md" "")

    # Normalize name: "Katie and Malcolm" → "katie.malcolm"
    let normalized_name = (normalize_person_name $basename)

    # Extract original frontmatter date if available
    let original_date = if ($content | str contains "date created:") {
        $content | lines | where {|line| $line | str contains "date created:"} | first | str replace "date created: " "" | str trim | str substring 0..10
    } else {
        "unknown-date"
    }

    # Extract original content (skip frontmatter)
    let lines = ($content | lines)
    let content_start = if ($lines.0 | str starts-with "---") {
        # Find second --- (end of frontmatter)
        let frontmatter_end = ($lines | skip 1 | enumerate | where item == "---" | get index.0) + 2
        $frontmatter_end
    } else {
        0
    }

    let original_content = ($lines | skip $content_start | str join (char nl) | str trim)

    # Create modern format
    let current_date = (date now | format date "%Y-%m-%d")
    let current_time = (date now | format date "%H:%M")

    let new_content = [
        "---"
        "tags:"
        "- social"
        $"date created: ($current_date) ($current_time)"
        $"date modified: ($current_date) ($current_time)"
        "---"
        $"# ($normalized_name)"
        ""
        "**Migrated from old system**"
        ""
        "## Journal Entries"
        ""
        $"### ($original_date) - historical"
        $"- ($original_content | str replace --all (char nl) (char nl + '  '))"
    ] | str join (char nl)

    let target_file = ([$napier_logs $"($normalized_name).md"] | path join)

    if ($target_file | path exists) {
        print $"  ⚠️  Skipping ($normalized_name) - file already exists"
        return false
    } else {
        $new_content | save $target_file
        if $verbose {
            print $"  ✓ Migrated: ($basename) → ($normalized_name).md"
        }
        return true
    }
}

# Normalize person names to lowercase dot-separated format
def normalize_person_name [name: string] {
    $name
    | str downcase
    | str replace " and " "."
    | str replace "&" "."
    | str replace "_" "."
    | str replace --all " " "."
    | str replace --regex "conv.*" ""  # Remove "conv pragmatism reading" suffix
    | str replace --regex "business.card.*" ""
    | str trim --char "."
}
