#!/usr/bin/env nu

# Cross-platform smart file opener - Rust/Nushell version  
# Opens files based on type using fd, rg, and platform-appropriate commands

def main [] {
    # Read the line from stdin
    let line = (^cat | str trim)
    
    # Extract path from various formats using regex
    let path = extract_path $line
    
    if ($path | is-empty) {
        return
    }
    
    # Try to find the file using fd (Rust tool)
    let found = find_file $path
    
    if ($found | is-empty) {
        "# File not found: " + $path | save -f /tmp/helix-gf-target.md
        return
    }
    
    # Get file extension
    let ext = ($found | path parse | get extension | str downcase)
    
    # Detect platform for system opener
    let platform = detect_platform
    let system_opener = match $platform {
        "macos" => "open",
        "linux" => "xdg-open",
        _ => "xdg-open"
    }
    
    # Handle based on file type
    match $ext {
        # Text/Code files - create symlink for Helix
        "md" | "txt" | "lua" | "rs" | "toml" | "json" | "yaml" | "yml" | 
        "sh" | "bash" | "zsh" | "nu" | "py" | "rb" | "go" | "c" | "cpp" | 
        "h" | "hpp" | "js" | "ts" | "css" | "html" | "xml" | "vim" | 
        "conf" | "ini" | "cfg" | "log" => {
            # Create symlink for Helix to open
            ^ln -sf $found /tmp/helix-gf-target.md
        }
        
        # Non-text files - open with system default app
        _ => {
            # Open with platform-appropriate system opener
            ^$system_opener $found
            # Create message file for Helix
            $"# Opened ($found) in external app" | save -f /tmp/helix-gf-target.md
        }
    }
}

# Detect current platform
def detect_platform [] {
    let os = (sys host | get name)
    match $os {
        "Darwin" => "macos",
        "Linux" => "linux", 
        _ => "unknown"
    }
}

# Extract path from line using Nushell regex
def extract_path [line: string] {
    # Wiki links: ![[path]] or [[path]]
    let wiki_match = ($line | parse -r '\!?\[\[([^\]]+)\]\]')
    if not ($wiki_match | is-empty) {
        return ($wiki_match | get 0 | get capture0)
    }
    
    # Markdown links: [text](path)
    let md_match = ($line | parse -r '\]\(([^\)]+)\)')
    if not ($md_match | is-empty) {
        return ($md_match | get 0 | get capture0)
    }
    
    # Quoted paths (simplified)
    let quote_match = ($line | parse -r '"([^"]+)"')
    if not ($quote_match | is-empty) {
        return ($quote_match | get 0 | get capture0)
    }
    
    # Path-like strings with extensions (using rg for better regex)
    let ext_patterns = [
        "md" "pdf" "png" "jpg" "jpeg" "txt" "lua" "rs" "toml" "json" 
        "yaml" "yml" "sh" "bash" "zsh" "nu" "mp4" "mov" "avi" "mp3" 
        "wav" "docx" "xlsx" "pptx" "html" "css" "js" "ts" "py" "rb" 
        "go" "c" "cpp" "h" "hpp" "svg" "gif"
    ]
    
    for ext in $ext_patterns {
        let pattern = $'[^[:space:]#]+\.($ext)'
        let rg_results = (echo $line | ^rg -o $pattern | lines)
        if ($rg_results | length) > 0 {
            return ($rg_results | first)
        }
    }
    
    # Path with slashes using rg
    let slash_results = (echo $line | ^rg -o '[^[:space:]]*\/[^[:space:]]+' | lines)
    if ($slash_results | length) > 0 {
        return ($slash_results | first)
    }
    
    # Filename with extension using rg  
    let file_results = (echo $line | ^rg -o '[^[:space:]]+\.[^[:space:]]+' | lines)
    if ($file_results | length) > 0 {
        return ($file_results | first)
    }
    
    return ""
}

# Find file using fd (cross-platform)
def find_file [path: string] {
    # Check if absolute path exists
    if ($path | str starts-with "/") and ($path | path exists) {
        return $path
    }
    
    # Check relative to current directory
    if ($path | path exists) {
        return ($path | path expand)
    }
    
    # Search in platform-appropriate vault paths
    let vault_paths = match (detect_platform) {
        "macos" => [
            "/Obsidian.nosync/Forge"
            "/Documents/Obsidian" 
            "/Obsidian"
        ],
        "linux" => [
            $"($env.HOME)/Obsidian/Forge"
            $"($env.HOME)/Documents/Obsidian"
            $"($env.HOME)/vault"
        ],
        _ => [$"($env.HOME)/Obsidian"]
    }
    
    for vault in $vault_paths {
        if not ($vault | path exists) {
            continue
        }
        
        # Try exact path match using fd
        let exact_results = (^fd --type f --full-path $path $vault | lines)
        if ($exact_results | length) > 0 {
            let exact_search = ($exact_results | first)
            if ($exact_search | path exists) {
                return $exact_search
            }
        }
        
        # Try with .md extension using fd
        let md_name = ($path + ".md")
        let md_results = (^fd --type f $md_name $vault | lines)
        if ($md_results | length) > 0 {
            let md_search = ($md_results | first)
            if ($md_search | path exists) {
                return $md_search
            }
        }
        
        # Try base filename search using fd (for wiki links)
        let basename = ($path | path basename)
        let basename_results = (^fd --type f $basename $vault | lines)
        if ($basename_results | length) > 0 {
            let basename_search = ($basename_results | first)
            if ($basename_search | path exists) {
                return $basename_search
            }
        }
    }
    
    return ""
}