#!/usr/bin/env nu

# Empirical test comparing tag search, content search, and semantic search
# Tests which files are found by each method and measures performance

def main [search_term: string] {
    let vault_path = "/Users/williamnapier/Forge"
    
    print $"=== SEARCH COMPARISON TEST FOR: '($search_term)' ==="
    print ""
    
    # 1. TAG SEARCH (YAML frontmatter tags)
    print "1. TAG SEARCH (via YAML frontmatter)"
    print "   Searching for files with tag: #($search_term)"
    
    let tag_start = (date now)
    let tag_results = (
        fd ".md$" $vault_path --type f 
        | lines 
        | par-each { |file|
            # Check both YAML formats: tags: [tag1, tag2] and tags: tag1
            let content = (open $file | str substring 0..500)  # Check first 500 chars for YAML
            if ($content | str contains "---") {
                # Extract YAML section
                let yaml_match = ($content | parse -r '(?s)^---\n(.*?)\n---')
                if ($yaml_match | length) > 0 {
                    let yaml = $yaml_match.0.capture0
                    # Check for tag in YAML list format: "- tagname"  
                    if ($yaml | str contains $"- ($search_term)") {
                        $file
                    }
                }
            }
        }
        | compact
    )
    let tag_end = (date now)
    let tag_duration = ($tag_end - $tag_start | format duration sec)
    
    print $"   Found: ($tag_results | length) files"
    print $"   Time: ($tag_duration)"
    if ($tag_results | length) > 0 {
        print "   Files:"
        $tag_results | each { |f| print $"     - ($f | path basename)" } | first 10
        if ($tag_results | length) > 10 {
            let extra = (($tag_results | length) - 10)
            print $"     ... and ($extra) more"
        }
    }
    print ""
    
    # 2. CONTENT SEARCH (word mentions, excluding tag sections)
    print "2. CONTENT SEARCH (word mentions, excluding tags)"
    print $"   Searching for: '($search_term)' in file content, excluding tag sections"
    
    let content_start = (date now)
    # Find files containing the term, then filter out those that only have it in tags
    let all_content_files = (
        rg -l -w --type md $search_term $vault_path 
        | complete
        | get stdout 
        | lines
        | where { |line| $line != "" }
    )
    
    # Filter to files that have the term in actual content, not just tags
    let content_results = (
        $all_content_files | par-each { |file|
            # Use ripgrep with word boundaries to search only after YAML frontmatter  
            let rg_result = (
                rg -n -w $search_term $file 
                | complete
                | get stdout
                | lines
                | each { |line| 
                    # Parse line number and content  
                    let parts = ($line | split column ":" line_num content)
                    if ($parts | length) > 0 {
                        {line: ($parts.line_num.0 | into int), content: ($parts.content.0 | str join ":")}
                    }
                }
                | compact
                | where { |item| 
                    # Only include lines after YAML frontmatter (typically after line 10)
                    # More robust: check if line doesn't start with "- " (tag format)
                    ($item.line > 15) and not ($item.content | str starts-with "- ")
                }
            )
            
            # If we found matches outside YAML/tags, include this file
            if ($rg_result | length) > 0 {
                $file
            }
        }
        | compact
    )
    let content_end = (date now)
    let content_duration = ($content_end - $content_start | format duration sec)
    
    print $"   Found: ($content_results | length) files"
    print $"   Time: ($content_duration)"
    if ($content_results | length) > 0 {
        print "   Files:"
        $content_results | each { |f| print $"     - ($f | path basename)" } | first 10
        if ($content_results | length) > 10 {
            let extra = (($content_results | length) - 10)
            print $"     ... and ($extra) more"
        }
    }
    print ""
    
    # 3. SEMANTIC SEARCH (if available)
    print "3. SEMANTIC SEARCH (conceptually related files)"
    print "   Example: searching 'attention' should find 'jfa' files (Junk Food Attention)"
    
    let semantic_available = (which semantic-query | length) > 0
    let semantic_results = if $semantic_available {
        print $"   Searching semantically for: '($search_term)'"
        
        let semantic_start = (date now)
        # Get API key from Keychain and run semantic-query
        let api_key = (security find-generic-password -s "openai-api-key" -a "semantic-search" -w | complete | get stdout | str trim)
        let semantic_output = if ($api_key | str length) > 0 {
            with-env { OPENAI_API_KEY: $api_key } { semantic-query --text $search_term --limit 20 | complete }
        } else {
            {exit_code: 1, stdout: "", stderr: "No API key in Keychain"}
        }
        
        let results = if $semantic_output.exit_code == 0 {
            # Parse semantic-query output format (similarity score + filename)
            $semantic_output.stdout 
            | lines 
            | skip 2  # Skip header lines
            | each { |line|
                if ($line | str contains "  ") {
                    # Extract filename after the similarity score
                    let filename = ($line | str substring 5.. | str trim)
                    $"($vault_path)/($filename).md"
                }
            }
            | compact
        } else {
            print $"   Semantic search failed: ($semantic_output.stderr)"
            []
        }
        
        let semantic_end = (date now)
        let semantic_duration = ($semantic_end - $semantic_start | format duration sec)
        
        print $"   Found: ($results | length) files"
        print $"   Time: ($semantic_duration)"
        if ($results | length) > 0 {
            print "   Files:"
            $results | each { |f| print $"     - ($f | path basename)" } | first 10
            if ($results | length) > 10 {
                let extra = (($results | length) - 10)
                print $"     ... and ($extra) more"
            }
        }
        $results
    } else {
        print "   Semantic search not available (semantic-query not found)"
        []
    }
    print ""
    
    # 4. COMPARISON ANALYSIS
    print "=== COMPARISON ANALYSIS ==="
    print ""
    
    # Convert to sets for comparison
    let tag_set = ($tag_results | path basename | uniq | sort)
    let content_set = ($content_results | path basename | uniq | sort)
    
    # Files found by tags but not content
    let tag_only = ($tag_set | where { |f| $f not-in $content_set })
    if ($tag_only | length) > 0 {
        print "Files found ONLY by tag search:"
        $tag_only | each { |f| print $"  - ($f)" }
        print ""
    }
    
    # Files found by content but not tags
    let content_only = ($content_set | where { |f| $f not-in $tag_set })
    if ($content_only | length) > 0 {
        print "Files found ONLY by content search:"
        $content_only | first 20 | each { |f| print $"  - ($f)" }
        if ($content_only | length) > 20 {
            let extra = (($content_only | length) - 20)
            print $"  ... and ($extra) more"
        }
        print ""
    }
    
    # Overlap
    let overlap = ($tag_set | where { |f| $f in $content_set })
    print $"Files found by BOTH methods: ($overlap | length)"
    print ""
    
    # Summary statistics
    print "=== SUMMARY ==="
    print $"Tag search:     ($tag_results | length) files in ($tag_duration)"
    print $"Content search: ($content_results | length) files in ($content_duration)"
    if $semantic_available {
        let semantic_set = ($semantic_results | path basename | uniq | sort)
        print $"Semantic search: ($semantic_results | length) files"
    }
    print ""
    
    # Performance comparison
    let tag_ms = ($tag_end - $tag_start | into int) / 1_000_000
    let content_ms = ($content_end - $content_start | into int) / 1_000_000
    
    if $tag_ms > 0 {
        let speedup = $tag_ms / $content_ms
        if $speedup > 1 {
            print $"Content search is (($speedup | math round -p 1))x FASTER than tag search!"
        } else {
            let slowdown = $content_ms / $tag_ms
            print $"Tag search is (($slowdown | math round -p 1))x faster than content search"
        }
    }
    
    print ""
    print "=== INSIGHTS ==="
    if ($content_only | length) > ($tag_only | length) {
        let extra = ($content_only | length) - ($tag_only | length)
        print $"Content search found ($extra) MORE files than tag search"
        print "This suggests natural language captures more relevant content than formal tags"
    } else if ($tag_only | length) > 0 {
        print $"Tag search found ($tag_only | length) files that content search missed"
        print "These files have the tag but don't mention the term in content"
    }
    
    # Test with quoted phrases
    if ($search_term | str contains " ") {
        print ""
        print "TIP: For multi-word searches, try with quotes for exact phrases"
    }
}

# Run multiple test cases
def "main batch" [] {
    let test_terms = [
        "productivity"
        "meeting"
        "coffee"
        "research"
        "daily"
    ]
    
    print "BATCH TESTING MULTIPLE SEARCH TERMS"
    print "===================================="
    print ""
    
    for term in $test_terms {
        main $term
        print "\n----------------------------------------\n"
    }
}