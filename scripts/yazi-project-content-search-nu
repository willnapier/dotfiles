#!/usr/bin/env nu

# Project-aware content search for Yazi (Nushell version)
# Supports multiple search terms with AND/OR logic
# Usage: yazi-project-content-search-nu "term1 AND term2"
#        yazi-project-content-search-nu "term1 OR term2"  
#        yazi-project-content-search-nu "single-term"

def main [search_query: string] {
    # Get project root using the enhanced function
    let project_info = (find-project-root-enhanced)
    let project_root = $project_info.path
    
    if ($project_root | is-empty) {
        print "Error: Could not detect project root"
        exit 1
    }
    
    print $"🔍 Content search in: ($project_root)"
    
    # Parse search query for multiple terms and quoted phrases
    let search_pattern = if ($search_query | str contains " AND ") {
        # AND logic - all terms must be present (in any order)
        # Handle quoted phrases by keeping them intact
        let terms = ($search_query | split row " AND " | each { |term| 
            let trimmed = ($term | str trim)
            # Remove surrounding quotes if present but keep the phrase intact
            if ($trimmed | str starts-with '"') and ($trimmed | str ends-with '"') {
                $trimmed | str substring 1..-1
            } else {
                $trimmed
            }
        })
        # For AND logic with ripgrep, we need to chain multiple searches
        # Return the first term and we'll chain the rest
        if ($terms | length) > 1 {
            # Create a pattern that requires all terms (using lookahead assertions)
            let patterns = ($terms | each { |term| $"(?=.*($term))" } | str join "")
            $"($patterns).*"
        } else {
            $terms.0
        }
    } else if ($search_query | str contains " OR ") {
        # OR logic - any term can match
        let terms = ($search_query | split row " OR " | each { |term| 
            let trimmed = ($term | str trim)
            # Remove surrounding quotes if present but keep the phrase intact
            if ($trimmed | str starts-with '"') and ($trimmed | str ends-with '"') {
                $trimmed | str substring 1..-1
            } else {
                $trimmed
            }
        })
        $terms | str join "|"
    } else if ($search_query | str starts-with '"') and ($search_query | str ends-with '"') {
        # Single quoted phrase - remove quotes
        $search_query | str substring 1..-1
    } else {
        # Single term search
        $search_query
    }
    
    print $"Searching for: '($search_query)'..."
    
    # Run ripgrep content search from project root
    cd $project_root
    let search_results = (
        rg --line-number --color=never --smart-case --type=md $search_pattern . 
        | complete
        | if $in.exit_code == 0 { $in.stdout } else { "" }
    )
    
    if ($search_results | is-empty) {
        print $"No matches found for '($search_query)'"
        exit 0
    }
    
    print "Found matches, opening picker..."
    
    # Use skim to select from results
    let selected = (
        $search_results 
        | ^sk --delimiter=":" --header=$"Content search for '($search_query)' in: (basename $project_root)"
    )
    
    # Parse selection and output file path with line number
    if not ($selected | is-empty) {
        let parts = ($selected | split column ":" file line rest)
        let file_path = $parts.file.0
        let line_number = $parts.line.0
        
        # Make path absolute and output
        let absolute_path = ($project_root | path join $file_path)
        print $"($absolute_path):($line_number)"
    }
}