#!/usr/bin/env nu
# Unified collection system for projects (P.) and activities (p::, t::, r::, etc.)
# Collects from daily journals to organized files with automatic linking
# Three-tier automation: manual, cron, or auto-save trigger

def main [
    --verbose (-v)      # Show detailed output
    --dry-run (-d)      # Show what would be collected without writing
] {
    let forge_root = ([$env.HOME "Forge"] | path join)
    let journal_path = ([$forge_root "NapierianLogs" "DayPages"] | path join)
    let projects_path = ([$forge_root "Projects"] | path join)
    let activities_path = ([$forge_root "NapierianLogs"] | path join)
    let social_path = ([$forge_root "NapierianLogs" "Social"] | path join)
    let reminders_path = ([$forge_root "NapierianLogs" "Reminders"] | path join)

    if not ($journal_path | path exists) {
        print $"Error: Journal path not found: ($journal_path)"
        return
    }

    # Ensure destination directories exist
    mkdir $projects_path
    mkdir $activities_path
    mkdir $social_path
    mkdir $reminders_path

    if $verbose {
        print "=== Entry Collection Started ==="
        print $"Journal: ($journal_path)"
        print $"Projects: ($projects_path)"
        print $"Activities: ($activities_path)"
        print $"Social: ($social_path)"
        print $"Reminders: ($reminders_path)\n"
    }

    # Find all entries (both P. projects and lowercase activities) in journal files
    let entries = (
        collect_entries $journal_path $verbose
    )

    if ($entries | is-empty) {
        if $verbose { print "No project entries found" }
        return
    }

    if $verbose {
        print $"Found ($entries | length) entries\n"
    }

    # Separate reminder entries (r::) from other entries
    let reminder_entries = ($entries | where { |e| $e.key == "r" })
    let other_entries = ($entries | where { |e| $e.key != "r" })

    # Process reminder entries
    if ($reminder_entries | length) > 0 {
        if $verbose {
            print $"Processing ($reminder_entries | length) reminder entries..."
        }
        process_reminder_entries $reminders_path $reminder_entries $dry_run $verbose
    }

    # Group remaining entries by hierarchy (works for both projects and activities)
    let grouped = (
        $other_entries
        | group-by {|entry|
            parse_entry_hierarchy $entry.key | get filepath
        }
    )

    # Process each entry group (project or activity)
    $grouped | transpose filepath entries | each {|group|
        let hierarchy = (parse_entry_hierarchy ($group.entries | first | get key))

        # Determine destination based on entry type
        # Priority: Projects (P.) → Social (if file exists) → Activities
        let destination = if ($hierarchy.key | str starts-with 'P.') {
            $projects_path
        } else {
            # Check if a Social file exists for this key
            let social_file = ([$social_path $"($hierarchy.filepath).md"] | path join)
            if ($social_file | path exists) {
                $social_path
            } else {
                $activities_path
            }
        }

        if $dry_run {
            print $"Would update: ($hierarchy.filepath).md"
            print $"  Entries: ($group.entries | length)"
            print $"  Destination: ($destination)"
        } else {
            update_entry_file $destination $hierarchy $group.entries $verbose
        }
    }

    if $verbose {
        print "\n=== Collection Complete ==="
    }

    # Automatic activity classification (runs only on Nimbini to prevent race conditions)
    # Only run if not dry-run and OPENAI_API_KEY is available
    if not $dry_run and ($env.OPENAI_API_KEY? | is-not-empty) {
        if $verbose {
            print "\n=== Running AI Classification ==="
            print "Classifying activity files with semantic tags..."
        }

        try {
            # Run classification on all activity files
            if $verbose {
                auto-tag-activities --verbose
            } else {
                auto-tag-activities
            }
        } catch {
            print "⚠️  Classification failed - continuing without tags"
            if $verbose {
                print $"Error: ($in)"
            }
        }
    } else if not $dry_run and ($env.OPENAI_API_KEY? | is-empty) {
        if $verbose {
            print "\n⚠️  Skipping classification: OPENAI_API_KEY not set"
        }
    }

    # Generate sub-activity lists (populates {Auto-generated} placeholders)
    # Runs after collection and classification to ensure parent/child relationships are current
    if not $dry_run {
        if $verbose {
            print "\n=== Generating Sub-Activity Lists ==="
            print "Populating {Auto-generated} placeholders in parent files..."
        }

        try {
            # Run sub-activity list generation
            if $verbose {
                generate-subactivity-lists --verbose
            } else {
                generate-subactivity-lists
            }
        } catch {
            print "⚠️  Sub-activity list generation failed - continuing"
            if $verbose {
                print $"Error: ($in)"
            }
        }
    }

    # Ensure Social files exist for leading :: patterns (inline entity references)
    # This allows typing ::colindye to auto-create Social/colindye.md
    if not $dry_run {
        if $verbose {
            print "\n=== Ensuring Social Files for :: Patterns ==="
        }
        ensure_social_files_for_leading_patterns $journal_path $social_path $verbose
    }
}

# Check if an activity file has "social" tag (for mention collection)
def is_social_activity [activities_path: string, activity_name: string]: nothing -> bool {
    let file_path = ([$activities_path $"($activity_name).md"] | path join)

    if not ($file_path | path exists) {
        return false
    }

    let content = (open $file_path)
    ($content | str contains "tags:") and ($content | str contains "- social")
}

# Extract all entries (P. projects and lowercase activities) from journal files
# Also collects mentions of social activities (people) when found in prose
def collect_entries [journal_path: string, verbose: bool] {
    let files = (glob ([$journal_path "**" "*.md"] | path join))
    let activities_path = ([$env.HOME "Forge" "NapierianLogs"] | path join)

    if $verbose {
        print $"Scanning ($files | length) journal files..."
    }

    $files | each {|file|
        let content = (open $file)
        let date = extract_date_from_filename $file
        let all_lines = ($content | lines)

        # Collect explicit activity entries (with ::)
        let explicit_entries = (
            $all_lines
            | enumerate
            | where {|row| $row.item =~ '[a-zA-Z][a-z0-9.]*::'}
            | each {|row|
                let parsed = (parse_entry_line $row.item)
                if ($parsed | is-not-empty) {
                    # parse_entry_line returns a list of matches (handles multiple per line)
                    $parsed | each {|entry|
                        # Capture narrative continuation if present
                        let narrative = (capture_narrative $all_lines $row.index $entry.content)

                        $entry | merge {
                            file: $file
                            date: $date
                            line_number: $row.index
                            narrative: $narrative
                            is_mention: false
                        }
                    }
                }
            }
            | flatten
        )

        # Collect mentions (lowercase patterns without ::, social activities only)
        let mentions = (
            $all_lines
            | enumerate
            | each {|row|
                # Find all lowercase dot-separated patterns (no ::)
                let matches = ($row.item | parse --regex '(?<![:\w])([a-z][a-z0-9.]+)(?!::)')

                $matches | each {|match|
                    let activity_name = $match.capture0

                    # Check if this is a social activity
                    if (is_social_activity $activities_path $activity_name) {
                        {
                            key: $activity_name
                            content: $"Mention: ($row.item | str trim)"
                            file: $file
                            date: $date
                            line_number: $row.index
                            narrative: ""
                            is_mention: true
                        }
                    }
                }
            }
            | flatten
            | where $it != null
        )

        # Combine explicit entries and mentions
        [$explicit_entries, $mentions] | flatten
    }
    | flatten
    | compact
    | uniq-by key content date  # Deduplicate by key, content, and date
}

# Capture narrative continuation after an entry
# Narrative starts after period on same line OR on next line
# Continues until empty line
def capture_narrative [all_lines: list<string>, entry_line_idx: int, entry_content: string] {
    # Check if entry content ends with period (inline continuation possible)
    let entry_line = ($all_lines | get $entry_line_idx)

    # Find where the entry ends on its line
    let entry_end_pattern = $"($entry_content)"

    # Check for inline narrative (after period on same line)
    let inline_narrative = if ($entry_line =~ '\.\s+[A-Z]') {
        # Pattern: "entry content. Narrative starts here"
        # Extract text after first period that follows entry content
        let after_entry = ($entry_line | str replace --regex '.*?::\s*[^.]+\.\s*' '')
        if ($after_entry | is-empty) or ($after_entry | str starts-with 'P.') or ($after_entry | str starts-with 'p') or ($after_entry | str starts-with 't') or ($after_entry | str starts-with 'r') {
            ""  # Next entry starts, no inline narrative
        } else {
            $after_entry | str trim
        }
    } else {
        ""
    }

    # Check for continuation on following lines
    let start_idx = ($entry_line_idx + 1)
    let max_lines = ($all_lines | length)

    mut continuation_lines = []
    mut current_idx = $start_idx

    # Read lines until empty line or end of file
    while $current_idx < $max_lines {
        let line = ($all_lines | get $current_idx)

        # Stop at empty line
        if ($line | str trim | is-empty) {
            break
        }

        # Stop at next entry (starts with key::)
        if ($line =~ '[a-zA-Z][a-z0-9.]*::') {
            break
        }

        # Stop at markdown headers
        if ($line | str starts-with '#') {
            break
        }

        # Add line to continuation
        $continuation_lines = ($continuation_lines | append ($line | str trim))
        $current_idx = ($current_idx + 1)
    }

    # Combine inline and continuation narratives
    let full_narrative = if ($inline_narrative | is-not-empty) and (not ($continuation_lines | is-empty)) {
        [$inline_narrative, ($continuation_lines | str join ' ')] | str join ' '
    } else if ($inline_narrative | is-not-empty) {
        $inline_narrative
    } else if (not ($continuation_lines | is-empty)) {
        $continuation_lines | str join ' '
    } else {
        ""
    }

    $full_narrative
}

# Parse a line with unified notation (projects P. and activities)
# Uses unified syntax: period and comma are delimiters, space separates attributes
# Supports: P.project:: 2hr description-with-hyphens
#          piano.cl:: 45min JSBach-WTC-I
#          travel.uber:: uber 30min £15
#          P.proj1:: 1hr work. piano:: 30min practice. (period-separated)
#          travel:: walk:: toEB 1.07km, walk:: toPractice 1.06km (inline nesting)
#
# PARSING RULES:
# - Each key:: is collected to its own file based on the key name
# - Keys with dots (ex.walk::) go to ex.walk.md
# - Nesting context (travel:: ... walk::) does NOT create composite keys
# - Each activity is tracked independently regardless of context
def parse_entry_line [line: string] {
    # Find all key:: patterns using ripgrep to get positions
    let rg_result = (
        $line | rg --only-matching --byte-offset '[a-zA-Z][a-zA-Z0-9.-]*::'
        | lines
        | each {|match_line|
            let parts = ($match_line | split row ':' | take 2)
            let offset = ($parts.0 | into int)
            let key = ($parts.1)
            {offset: $offset, key: $key}
        }
    )

    if ($rg_result | is-empty) {
        return null
    }

    mut results = []

    for item in ($rg_result | enumerate) {
        let match_info = $item.item
        let idx = $item.index
        let raw_key = $match_info.key

        # Each key goes to its own file - no composite keys from nesting
        let full_key = $raw_key

        # Extract content: from after this key:: to next key:: or delimiter
        let start_pos = ($match_info.offset + ($raw_key | str length) + 2)  # +2 for '::'

        let end_pos = if ($idx + 1) < ($rg_result | length) {
            ($rg_result | get ($idx + 1) | get offset)
        } else {
            ($line | str length)
        }

        let content_str = if $start_pos < $end_pos {
            $line | str substring $start_pos..<$end_pos
        } else {
            ""
        }

        # Find delimiters within content to trim
        let comma_pos = ($content_str | str index-of ',')
        let period_space_pos = ($content_str | str index-of '. ')

        let valid_delimiters = ([$comma_pos, $period_space_pos] | where $it >= 0)

        let final_content = if ($valid_delimiters | is-empty) {
            $content_str | str trim | str trim --char '.'
        } else {
            let delimiter_pos = ($valid_delimiters | math min)
            $content_str | str substring 0..<$delimiter_pos | str trim | str trim --char '.'
        }

        $results = ($results | append {key: $full_key, content: $final_content})
    }

    $results
}

# Parse hierarchy from entry key (works for both P.project and piano.cl activities)
def parse_entry_hierarchy [key: string] {
    # Remove P. prefix if present, otherwise use key as-is
    let clean_key = if ($key | str starts-with 'P.') {
        $key | str replace 'P.' ''
    } else {
        $key
    }

    let parts = ($clean_key | split row '.')

    {
        key: $key                                      # Original key (P.project or piano.cl)
        root: ($parts | first)                         # First part (project or piano)
        subproject: ($parts | skip 1 | str join '.')  # Remaining parts
        filepath: ($parts | str join '.')             # Full path (project.child or piano.cl)
        depth: ($parts | length)                       # Hierarchy depth
    }
}

# Extract date from journal filename (assumes YYYY-MM-DD format)
def extract_date_from_filename [filepath: string] {
    let filename = ($filepath | path basename | str replace '.md' '')

    # Try to parse YYYY-MM-DD format
    let date_match = ($filename | parse --regex '(\d{4}-\d{2}-\d{2})')

    if ($date_match | is-not-empty) {
        $date_match | first | get capture0
    } else {
        # Fallback to file modification time
        ls $filepath | first | get modified | format date "%Y-%m-%d"
    }
}

# Update or create entry file (project or activity)
def update_entry_file [
    destination_path: string
    hierarchy: record
    entries: list
    verbose: bool
] {
    let filepath = $"($destination_path)/($hierarchy.filepath).md"
    let entry_name = $hierarchy.root

    # Check if file exists
    let exists = ($filepath | path exists)

    if not $exists {
        # Create new project file
        if $verbose {
            print $"Creating: ($hierarchy.filepath).md"
        }

        let content = generate_project_template $hierarchy $entries
        $content | save $filepath
    } else {
        # Append new entries
        if $verbose {
            print $"Updating: ($hierarchy.filepath).md with ($entries | length) entries"
        }

        append_entries_to_project $filepath $entries
    }

    # Update parent with subentry link if needed (for hierarchical entries like piano.cl or P.parent.child)
    if $hierarchy.depth > 1 {
        let parent_path = $"($destination_path)/($hierarchy.root).md"
        if ($parent_path | path exists) {
            add_subentry_to_parent $parent_path $hierarchy.filepath
        }
    }
}

# Generate new entry file from template (works for both projects and activities)
def generate_project_template [hierarchy: record, entries: list] {
    let today = (date now | format date "%Y-%m-%d")
    let entry_name = $hierarchy.filepath

    # Determine if this is a project (P.) or activity
    let is_project = ($hierarchy.key | str starts-with 'P.')

    let header = if $hierarchy.depth == 1 {
        # Root entry (project or top-level activity)
        if $is_project {
            # Project template
            $"# ($entry_name)

**Type**: {type}
**Status**: Active
**Created**: ($today)
**Updated**: ($today)

## Overview

{Project description}

## Subprojects

{Auto-generated}

## Journal Entries
"
        } else {
            # Activity template (simpler)
            $"# ($entry_name)

**Created**: ($today)
**Updated**: ($today)

## Sub-activities

{Auto-generated}

## Journal Entries
"
        }
    } else {
        # Child entry (subproject or sub-activity)
        let section_name = if $is_project { "Subprojects" } else { "Sub-activities" }
        $"# ($entry_name)

**Parent**: [[($hierarchy.root)]]
**Created**: ($today)

## Journal Entries
"
    }

    let entries_text = format_entries $entries

    $"($header)\n($entries_text)"
}

# Append entries to existing project file
def append_entries_to_project [filepath: string, entries: list] {
    let existing = (open $filepath)

    # Check for ## Journal Entries section
    if not ($existing =~ '## Journal Entries') {
        # Add section if missing
        let updated = $"($existing)\n\n## Journal Entries\n"
        $updated | save -f $filepath
    }

    # Filter out duplicates by checking if entry content already exists
    let new_entries = ($entries | where {|entry|
        # Create the entry line format that would appear in the file
        let entry_line = $"- ($entry.content)"
        # Check if this exact line already exists in the file
        not ($existing | str contains $entry_line)
    })

    # Only append if there are new entries
    if ($new_entries | is-empty) {
        return
    }

    # Format new entries
    let formatted_entries = format_entries $new_entries

    # Append to file
    let content = (open $filepath)
    $"($content)\n($formatted_entries)" | save -f $filepath
}

# Format entries for journal section (with optional narrative)
def format_entries [entries: list] {
    $entries
    | group-by date
    | transpose date entries
    | sort-by date --reverse
    | each {|day|
        let entry_lines = (
            $day.entries
            | each {|entry|
                # Format: "- content" or "- content - narrative" if narrative exists
                if ($entry.narrative | is-not-empty) {
                    $"- ($entry.content) - ($entry.narrative)"
                } else {
                    $"- ($entry.content)"
                }
            }
            | str join "\n"
        )

        $"### ($day.date)\n($entry_lines)"
    }
    | str join "\n\n"
}

# Add subentry link to parent file (works for both projects and activities)
def add_subentry_to_parent [parent_file: string, subentry_name: string] {
    let content = (open $parent_file)

    # Check if already listed
    let link = $"[[($subentry_name)]]"
    if ($content | str contains $link) {
        return  # Already there
    }

    # Find ## Subprojects or ## Sub-activities section
    let section_name = if ($content =~ '## Subprojects') {
        '## Subprojects'
    } else if ($content =~ '## Sub-activities') {
        '## Sub-activities'
    } else {
        return  # No appropriate section exists
    }

    # Add link under the section
    let updated = (
        $content
        | str replace $section_name $"($section_name)\n- [[($subentry_name)]]"
    )

    $updated | save -f $parent_file
}

# Ensure Social files exist for leading :: patterns (inline entity references)
# Scans DayPages for ::name patterns and creates Social/{name}.md if not exists
def ensure_social_files_for_leading_patterns [
    journal_path: string
    social_path: string
    verbose: bool
] {
    let files = (glob ([$journal_path "**" "*.md"] | path join))

    # Collect all unique ::name patterns across all files
    let patterns = (
        $files | each {|file|
            let content = (open $file --raw)
            # Find all ::name patterns (leading ::)
            # Pattern: :: followed by lowercase letters/numbers/dots/hyphens
            # But NOT followed by another : (to avoid matching key:: patterns as ::key)
            try {
                $content | rg -o '::[a-z][a-z0-9.-]*' | lines
            } catch {
                []
            }
        }
        | flatten
        | uniq
    )

    if ($patterns | is-empty) {
        if $verbose {
            print "  No leading :: patterns found"
        }
        return
    }

    if $verbose {
        print $"  Found ($patterns | length) unique :: patterns"
    }

    # For each pattern, ensure Social file exists
    let current_date = (date now | format date "%Y-%m-%d")

    for pattern in $patterns {
        let name = ($pattern | str replace '::' '')

        # Skip very short names or reserved words
        if ($name | str length) <= 2 or ($name in ["dev", "sys", "env", "var", "tmp"]) {
            continue
        }

        let social_file = ([$social_path $"($name).md"] | path join)

        if ($social_file | path exists) {
            continue  # Already exists
        }

        # Create the Social file
        let content = $"# ($name)

**Created**: ($current_date)
**Updated**: ($current_date)

## Sub-activities

{Auto-generated}

## Journal Entries

## Backlinks

"
        $content | save -f $social_file

        if $verbose {
            print $"  ✓ Created Social/($name).md"
        }
    }
}

# Process r:: reminder entries
# Format: r:: <when>: <message>
# Example: r:: in 1 year: Check back on this thought
# Example: r:: next Tuesday: Call dentist
def process_reminder_entries [
    reminders_path: string
    entries: list
    dry_run: bool
    verbose: bool
] {
    for entry in $entries {
        let content = $entry.content
        let source_date = $entry.date
        let source_file = $entry.file

        # Parse content: "<when>: <message>"
        let colon_idx = ($content | str index-of ": ")

        if $colon_idx < 0 {
            if $verbose {
                print $"  ⚠️  Skipping malformed reminder - no ': ' separator: ($content)"
            }
            continue
        }

        let when_part = ($content | str substring 0..$colon_idx | str trim)
        let message = ($content | str substring ($colon_idx + 2).. | str trim)

        if ($message | is-empty) {
            if $verbose {
                print $"  ⚠️  Skipping reminder with empty message: ($content)"
            }
            continue
        }

        # Check if when_part is a bare time (e.g. "23:00", "00:00")
        # Bare times anchor to the source DayPage date, not date from-human
        let is_bare_time = ($when_part =~ '^\d{1,2}:\d{2}$')

        let target_date = if $is_bare_time {
            $source_date
        } else {
            try {
                $when_part | date from-human | format date "%Y-%m-%d"
            } catch {
                if $verbose {
                    print $"  ⚠️  Could not parse date '($when_part)' - skipping"
                }
                continue
            }
        }

        let time_part = if $is_bare_time {
            $when_part
        } else {
            try { $when_part | date from-human | format date "%H:%M" } catch { "00:00" }
        }
        # Check if the input contained a time pattern (digits with colon)
        let has_time = ($when_part =~ '\d{1,2}:\d{2}')

        let reminder_file = ([$reminders_path $"($target_date).md"] | path join)
        let wikilink = $"[[($source_date)]]"
        let time_marker = if $has_time { $" \(at ($time_part)\)" } else { "" }
        let reminder_line = $"- [ ] ($message)($time_marker) \(from ($wikilink)\)"

        if $dry_run {
            print $"  Would create reminder for ($target_date): ($message)"
            continue
        }

        # Check if this exact reminder already exists
        if ($reminder_file | path exists) {
            let existing = (open $reminder_file --raw)
            if ($existing | str contains $message) {
                if $verbose {
                    print $"  ⏭️  Reminder already exists for ($target_date): ($message)"
                }
                continue
            }
            # Append to existing file
            $"\n($reminder_line)" | save --append $reminder_file
        } else {
            # Create new file
            $"# Reminders for ($target_date)\n\n($reminder_line)" | save $reminder_file
        }

        if $verbose {
            print $"  ✓ Created reminder for ($target_date): ($message)"
        }
    }
}
