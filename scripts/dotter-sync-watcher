#!/usr/bin/env nu

# Dotter Sync Watcher - Auto-deploy when dotfiles change
# Watches ~/dotfiles for Syncthing updates and runs dotter deploy

# Auto-manage services after deployment with safety checks
def auto_manage_services [timestamp: string, log_file: path] {
    let os_name = (sys host | get name)

    if $os_name == "Linux" {
        # Check for new systemd service files
        let service_files = (try { ls ~/.config/systemd/user/*.service } | default [])
        let managed_services = ["wiki-link-manager", "syncthing-monitor", "git-auto-push-watcher"]

        for service in $managed_services {
            let service_file = $"~/.config/systemd/user/($service).service"

            if ($service_file | path exists) {
                # Check if service is already enabled to avoid unnecessary operations
                let is_enabled = (do { systemctl --user is-enabled $"($service).service" } | complete | get exit_code) == 0
                let is_active = (do { systemctl --user is-active $"($service).service" } | complete | get exit_code) == 0

                if not $is_enabled {
                    let enable_msg = $"[($timestamp)] üîß Auto-enabling systemd service: ($service)"
                    $enable_msg | save --append $log_file
                    print $"üîß Auto-enabling service: ($service)"

                    systemctl --user daemon-reload
                    systemctl --user enable $"($service).service"

                    if not $is_active {
                        systemctl --user start $"($service).service"
                        let start_msg = $"[($timestamp)] üöÄ Auto-started service: ($service)"
                        $start_msg | save --append $log_file
                        print $"üöÄ Started service: ($service)"
                    }
                } else if not $is_active {
                    # Service is enabled but not running - restart it
                    systemctl --user restart $"($service).service"
                    let restart_msg = $"[($timestamp)] üîÑ Auto-restarted service: ($service)"
                    $restart_msg | save --append $log_file
                    print $"üîÑ Restarted service: ($service)"
                }
            }
        }
    } else if $os_name == "Darwin" {
        # Check for new LaunchAgent plist files
        let plist_dir = $"($env.HOME)/Library/LaunchAgents"
        let managed_agents = ["com.williamnapier.wiki-link-manager", "com.williamnapier.syncthing-monitor", "com.williamnapier.git-auto-pull-watcher"]

        for agent in $managed_agents {
            let plist_file = $"($plist_dir)/($agent).plist"

            if ($plist_file | path exists) {
                # Check if LaunchAgent is loaded
                let is_loaded = (do { launchctl list | rg $agent } | complete | get exit_code) == 0

                if not $is_loaded {
                    let load_msg = $"[($timestamp)] üîß Auto-loading LaunchAgent: ($agent)"
                    $load_msg | save --append $log_file
                    print $"üîß Auto-loading agent: ($agent)"

                    launchctl load $plist_file
                } else {
                    # Agent is loaded but may need restart - unload and reload
                    launchctl unload $plist_file
                    launchctl load $plist_file
                    let reload_msg = $"[($timestamp)] üîÑ Auto-reloaded LaunchAgent: ($agent)"
                    $reload_msg | save --append $log_file
                    print $"üîÑ Reloaded agent: ($agent)"
                }
            }
        }
    }
}

def main [] {
    let dotfiles_dir = $"($env.HOME)/dotfiles"
    let log_file = $"($env.HOME)/.local/share/dotter-sync-watcher.log"
    let lock_file = "/tmp/dotter-sync-watcher.lock"
    let last_deploy = "/tmp/dotter-last-deploy"

    # Ensure log directory exists
    mkdir ($log_file | path dirname)

    # Smart lock file handling with stale lock detection
    if ($lock_file | path exists) {
        let lock_age = ((date now) - (ls $lock_file | get 0.modified))
        let age_minutes = ($lock_age / 1min)

        if $age_minutes > 10 {
            let timestamp = (date now | format date "%H:%M:%S")
            let age_rounded = ($age_minutes | math round)
            let cleanup_msg = $"[($timestamp)] üßπ Cleaning up stale lock file ($age_rounded) minutes old"
            $cleanup_msg | save --append $log_file
            print $cleanup_msg
            rm -f $lock_file
        } else {
            print "‚ùå Sync watcher already running (recent lock file)"
            exit 1
        }
    }

    # Create lock file
    "running" | save $lock_file

    print "üöÄ Starting Dotter sync watcher"
    print $"üëÄ Watching: ($dotfiles_dir)"
    print $"üìù Logging to: ($log_file)"

    # Initial deploy timestamp
    (date now | format date "%s") | save --force $last_deploy

    # Use infinite loop with file change detection
    # (Nushell doesn't have built-in file watching yet)
    print "‚ö†Ô∏è  Note: Using polling method (Nushell watch not yet available)"

    mut last_check = (try { ls $"($dotfiles_dir)/**/*.{toml,kdl,nu,sh,lua}" | get modified | math max } | default (date now))

    loop {
        sleep 2sec

        # Check for changes
        let current_files = (try { ls $"($dotfiles_dir)/**/*.{toml,kdl,nu,sh,lua}" } | default [])
        if ($current_files | is-empty) { continue }

        let latest_change = ($current_files | get modified | math max)

        if $latest_change > $last_check {
            let now = (date now | format date "%s" | into int)
            let last = (try { open $last_deploy | into int } catch { 0 })
            let elapsed = $now - $last

            # Debounce - only deploy once every 5 seconds
            if $elapsed > 5 {
                let timestamp = (date now | format date "%H:%M:%S")
                let message = $"[($timestamp)] Change detected in dotfiles"
                $message | save --append $log_file
                print $message

                # Run dotter deploy
                print "üîÑ Running dotter deploy..."
                cd $dotfiles_dir
                let result = (do { ~/.cargo/bin/dotter deploy } | complete)

                if $result.exit_code == 0 {
                    let deploy_msg = $"[($timestamp)] ‚úÖ Dotter deploy successful"
                    $deploy_msg | save --append $log_file
                    print "‚úÖ Config updated!"

                    # Check Helix config sync (platform-specific configs must stay aligned)
                    let helix_sync = (do { nu ~/.local/bin/helix-config-sync-check } | complete)
                    if $helix_sync.exit_code != 0 {
                        let sync_warn = $"[($timestamp)] ‚ö†Ô∏è  Helix configs out of sync!"
                        $sync_warn | save --append $log_file
                        print $sync_warn
                        print $helix_sync.stdout
                    }

                    # Auto-manage services after successful deployment
                    auto_manage_services $timestamp $log_file

                    # Run post-deploy verification to catch silent failures
                    let verify_result = (do { nu ~/.local/bin/dotter-verify --quiet } | complete)
                    if $verify_result.exit_code != 0 {
                        let verify_warn = $"[($timestamp)] ‚ö†Ô∏è  Post-deploy verification found issues"
                        $verify_warn | save --append $log_file
                        print $verify_warn
                        # Log the issues but don't fail the deploy
                        $verify_result.stdout | save --append $log_file
                    } else {
                        let verify_ok = $"[($timestamp)] ‚úì Post-deploy verification passed"
                        $verify_ok | save --append $log_file
                    }
                } else {
                    let error_msg = $"[($timestamp)] ‚ùå Deploy failed: ($result.stderr)"
                    $error_msg | save --append $log_file
                    print $"‚ùå Deploy failed: ($result.stderr)"

                    # Notify of failure via messageboard
                    let hostname = (sys host | get hostname)
                    do { messageboard-edit insert $"DEPLOY FAILED on ($hostname) - check logs" } | complete
                }

                # Update last deploy time
                (date now | format date "%s") | save --force $last_deploy
            }

            # Update last check time
            $last_check = $latest_change
        }
    }

    # Cleanup on exit
    rm -f $lock_file
    print "üõë Sync watcher stopped"
}