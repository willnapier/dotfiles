#!/bin/bash
# Scan all notes for unchecked todos and create a dynamic todo view
# Uses modern Rust tools: fd, rg, sk

FORGE="${FORGE:-$HOME/Forge}"
TODO_CACHE="$HOME/.cache/active-todos.md"
TODO_JSON="$HOME/.cache/active-todos.json"

# Color codes for terminal output
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
NC='\033[0m'

# Parse arguments
SHOW_CONTEXT=false
DAYS_BACK=30
INTERACTIVE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --all) DAYS_BACK=9999 ;;
        --week) DAYS_BACK=7 ;;
        --context) SHOW_CONTEXT=true ;;
        --edit) INTERACTIVE=true ;;
        --help)
            echo "Usage: todo-scanner [OPTIONS]"
            echo "Options:"
            echo "  --all      Show all todos (no time limit)"
            echo "  --week     Show todos from last 7 days only"
            echo "  --context  Show line after todo for context (cache mode)"
            echo "  --edit     Interactive picker, opens in Helix"
            echo "  --help     Show this help message"
            exit 0
            ;;
        *) echo "Unknown option: $1"; exit 1 ;;
    esac
    shift
done

# Build time filter for fd
if [ "$DAYS_BACK" -lt 9999 ]; then
    TIME_FILTER="--changed-within ${DAYS_BACK}d"
else
    TIME_FILTER=""
fi

# Interactive mode - fast path, skip cache generation
if $INTERACTIVE; then
    if [ -n "$TIME_FILTER" ]; then
        results=$(fd -e md $TIME_FILTER . "$FORGE" -0 2>/dev/null | xargs -0 rg -n "^\s*- \[ \]" 2>/dev/null)
    else
        results=$(rg -n "^\s*- \[ \]" --type md "$FORGE" 2>/dev/null)
    fi

    if [ -z "$results" ]; then
        echo "No todos found."
        exit 0
    fi

    # Use sk with preview showing context around the todo
    # Force xterm-256color as sk doesn't recognize some terminals (ghostty, wezterm, etc.)
    selected=$(echo "$results" | TERM=xterm-256color sk \
        --prompt "ðŸ“‹ Todo: " \
        --preview 'file=$(echo {} | cut -d: -f1); line=$(echo {} | cut -d: -f2); bat --color=always --wrap=never --highlight-line "$line" --line-range "$((line > 5 ? line - 5 : 1)):$((line + 10))" "$file" 2>/dev/null || head -20 "$file"' \
        --preview-window "right:60%" \
        --height "80%" \
        --bind "ctrl-y:execute-silent(echo {} | cut -d: -f3- | tr -d '\n' | pbcopy 2>/dev/null || echo {} | cut -d: -f3- | wl-copy 2>/dev/null)")

    if [ -n "$selected" ]; then
        filepath=$(echo "$selected" | cut -d: -f1)
        linenum=$(echo "$selected" | cut -d: -f2)

        # Open in editor at the specific line
        if command -v hx &>/dev/null; then
            hx "$filepath:$linenum"
        elif command -v nvim &>/dev/null; then
            nvim "+$linenum" "$filepath"
        else
            ${EDITOR:-vi} "+$linenum" "$filepath"
        fi
    fi
    exit 0
fi

echo -e "${YELLOW}Scanning for unchecked todos...${NC}"

# Header for the cache file
cat > "$TODO_CACHE" << EOF
# Active TODOs
*Generated: $(date '+%Y-%m-%d %H:%M')*
*Scope: Last $DAYS_BACK days*

---

EOF

# Start JSON
echo "[" > "$TODO_JSON"

# Track stats
TOTAL=0
first_json=true

# Use rg to search all matching files at once (MUCH faster than per-file grep)
# Output format: filepath:linenum:matched_line
while IFS=: read -r filepath line_num todo_line; do
    # Skip empty lines
    [[ -z "$filepath" ]] && continue

    # Get relative path
    rel_path="${filepath#$FORGE/}"

    # Clean up the todo text (remove leading whitespace and checkbox)
    todo_text="${todo_line#*- \[ \] }"
    todo_text="${todo_text#"${todo_text%%[![:space:]]*}"}"  # trim leading whitespace

    # Get file age
    modified=$(stat -f "%m" "$filepath" 2>/dev/null || stat -c "%Y" "$filepath" 2>/dev/null)
    now=$(date +%s)
    age_days=$(( (now - modified) / 86400 ))

    if [ $age_days -eq 0 ]; then
        age="today"
    elif [ $age_days -eq 1 ]; then
        age="yesterday"
    elif [ $age_days -lt 7 ]; then
        age="${age_days}d ago"
    elif [ $age_days -lt 30 ]; then
        age="$((age_days / 7))w ago"
    else
        age="$((age_days / 30))mo ago"
    fi

    # Category from first path component
    category="${rel_path%%/*}"

    # Write to markdown cache
    echo "## $category / $(basename "$filepath" .md) *($age)*" >> "$TODO_CACHE"
    echo "- [ ] $todo_text" >> "$TODO_CACHE"
    echo "  *[[${rel_path%.md}#L$line_num]]*" >> "$TODO_CACHE"

    # Add context if requested
    if $SHOW_CONTEXT; then
        context=$(sed -n "$((line_num + 1))p" "$filepath" 2>/dev/null)
        [ -n "$context" ] && echo "  > $context" >> "$TODO_CACHE"
    fi

    echo "" >> "$TODO_CACHE"

    # Write to JSON
    # Escape quotes in todo_text for JSON
    json_text="${todo_text//\"/\\\"}"

    if [ "$first_json" = false ]; then echo "," >> "$TODO_JSON"; fi
    first_json=false

    cat >> "$TODO_JSON" << EOJSON
  {
    "file": "$rel_path",
    "line": $line_num,
    "task": "$json_text",
    "modified": $modified,
    "category": "$category"
  }
EOJSON

    TOTAL=$((TOTAL + 1))
done < <(
    if [ -n "$TIME_FILTER" ]; then
        # Pipe through xargs to preserve filepath:linenum:content format
        fd -e md $TIME_FILTER . "$FORGE" -0 2>/dev/null | xargs -0 rg -n "^\s*- \[ \]" 2>/dev/null
    else
        rg -n "^\s*- \[ \]" --type md "$FORGE" 2>/dev/null
    fi
)

# Close JSON array
echo -e "\n]" >> "$TODO_JSON"

# Add statistics to markdown
file_count=$(fd -e md $TIME_FILTER . "$FORGE" 2>/dev/null | wc -l | tr -d ' ')

cat >> "$TODO_CACHE" << EOF

---

## Statistics
- **Total active todos**: $TOTAL
- **Scanned**: $file_count files
- **Time range**: Last $DAYS_BACK days
- **Last scan**: $(date '+%Y-%m-%d %H:%M')

EOF

# Summary output
echo -e "${GREEN}âœ“ Found $TOTAL active todos${NC}"
echo -e "${GREEN}âœ“ Saved to: $TODO_CACHE${NC}"
echo ""
echo "Quick commands:"
echo "  todo-scanner --edit            # Interactive picker â†’ Helix"
echo "  hx ~/.cache/active-todos.md    # View full list"
echo ""

if [ -n "$NU_VERSION" ]; then
    echo "For Nushell analysis:"
    echo "  open ~/.cache/active-todos.json | first 5"
fi
