#!/usr/bin/env nu

# Cross-platform system app opener - Rust/Nushell version
# Detects platform and uses appropriate opener command

def main [] {
    # Read the line from stdin
    let line = (^cat | str trim)
    
    # Detect platform
    let platform = detect_platform
    let opener_cmd = match $platform {
        "macos" => "open",
        "linux" => "xdg-open",
        _ => "xdg-open"  # fallback
    }
    
    # Extract path from various formats using regex
    let path = extract_path $line
    
    if ($path | is-empty) {
        return
    }
    
    # Try to find the file using fd (Rust tool)
    let found = find_file $path
    
    if ($found | is-empty) {
        return
    }
    
    # Open with platform-appropriate command
    ^$opener_cmd $found
}

# Detect current platform
def detect_platform [] {
    let os = (sys host | get name)
    match $os {
        "Darwin" => "macos",
        "Linux" => "linux", 
        _ => "unknown"
    }
}

# Extract path from line using Nushell regex  
def extract_path [line: string] {
    # Wiki links: ![[path]] or [[path]]
    let wiki_match = ($line | parse -r '\!?\[\[([^\]]+)\]\]')
    if not ($wiki_match | is-empty) {
        return ($wiki_match | get 0 | get capture0)
    }
    
    # Markdown links: [text](path)
    let md_match = ($line | parse -r '\]\(([^\)]+)\)')
    if not ($md_match | is-empty) {
        return ($md_match | get 0 | get capture0)
    }
    
    # Quoted paths (simplified)
    let quote_match = ($line | parse -r '"([^"]+)"')
    if not ($quote_match | is-empty) {
        return ($quote_match | get 0 | get capture0)
    }
    
    # Path-like strings with extensions (using rg for better regex)
    let ext_patterns = [
        "md" "pdf" "png" "jpg" "jpeg" "txt" "lua" "rs" "toml" "json" 
        "yaml" "yml" "sh" "bash" "zsh" "nu" "mp4" "mov" "avi" "mp3" 
        "wav" "docx" "xlsx" "pptx" "html" "css" "js" "ts" "py" "rb" 
        "go" "c" "cpp" "h" "hpp" "svg" "gif" "csv" "xls" "doc" "ppt"
        "zip" "tar" "gz" "dmg" "pkg" "app" "xcodeproj" "sketch"
    ]
    
    for ext in $ext_patterns {
        let pattern = $'[^[:space:]#]+\.($ext)'
        let rg_results = (echo $line | ^rg -o $pattern | lines)
        if ($rg_results | length) > 0 {
            return ($rg_results | first)
        }
    }
    
    # Path with slashes using rg
    let slash_results = (echo $line | ^rg -o '[^[:space:]]*\/[^[:space:]]+' | lines)
    if ($slash_results | length) > 0 {
        return ($slash_results | first)
    }
    
    # Filename with extension using rg  
    let file_results = (echo $line | ^rg -o '[^[:space:]]+\.[^[:space:]]+' | lines)
    if ($file_results | length) > 0 {
        return ($file_results | first)
    }
    
    return ""
}

# Find file using fd (cross-platform)
def find_file [path: string] {
    # Check if absolute path exists
    if ($path | str starts-with "/") and ($path | path exists) {
        return $path
    }
    
    # Check relative to current directory
    if ($path | path exists) {
        return ($path | path expand)
    }
    
    # Search in platform-appropriate vault paths
    let vault_paths = match (detect_platform) {
        "macos" => [
            "/Obsidian.nosync/Forge"
            "/Documents/Obsidian" 
            "/Obsidian"
        ],
        "linux" => [
            $"($env.HOME)/Obsidian/Forge"
            $"($env.HOME)/Documents/Obsidian"
            $"($env.HOME)/vault"
        ],
        _ => [$"($env.HOME)/Obsidian"]
    }
    
    for vault in $vault_paths {
        if not ($vault | path exists) {
            continue
        }
        
        # Try exact path match using fd
        let exact_results = (^fd --type f --full-path $path $vault | lines)
        if ($exact_results | length) > 0 {
            let exact_search = ($exact_results | first)
            if ($exact_search | path exists) {
                return $exact_search
            }
        }
        
        # Try with .md extension using fd
        let md_name = ($path + ".md")
        let md_results = (^fd --type f $md_name $vault | lines)
        if ($md_results | length) > 0 {
            let md_search = ($md_results | first)
            if ($md_search | path exists) {
                return $md_search
            }
        }
        
        # Try base filename search using fd (for wiki links)
        let basename = ($path | path basename)
        let basename_results = (^fd --type f $basename $vault | lines)
        if ($basename_results | length) > 0 {
            let basename_search = ($basename_results | first)
            if ($basename_search | path exists) {
                return $basename_search
            }
        }
    }
    
    return ""
}